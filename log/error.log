
20:27:15.292 [error] [{:board_check, 2} (Line 60)] {:<<>>, [line: 60], ["Wrong row at: ", {:"::", [line: 60], [{{:., [line: 60], [Kernel, :to_string]}, [line: 60], [{:row_number, [line: 60], nil}]}, {:binary, [line: 60], nil}]}, "  --- ", {:"::", [line: 60], [{{:., [line: 60], [Kernel, :to_string]}, [line: 60], [{:inspect, [line: 60], [{:row, [line: 60], nil}]}]}, {:binary, [line: 60], nil}]}]}
20:27:15.293 [error] [{:board_check, 2} (Line 60)] {:<<>>, [line: 60], ["Wrong row at: ", {:"::", [line: 60], [{{:., [line: 60], [Kernel, :to_string]}, [line: 60], [{:row_number, [line: 60], nil}]}, {:binary, [line: 60], nil}]}, "  --- ", {:"::", [line: 60], [{{:., [line: 60], [Kernel, :to_string]}, [line: 60], [{:inspect, [line: 60], [{:row, [line: 60], nil}]}]}, {:binary, [line: 60], nil}]}]}
20:27:27.246 [error] [{:board_check, 2} (Line 60)] {:<<>>, [line: 60], ["Wrong row at: ", {:"::", [line: 60], [{{:., [line: 60], [Kernel, :to_string]}, [line: 60], [{:row_number, [line: 60], nil}]}, {:binary, [line: 60], nil}]}, "  --- ", {:"::", [line: 60], [{{:., [line: 60], [Kernel, :to_string]}, [line: 60], [{:inspect, [line: 60], [{:row, [line: 60], nil}]}]}, {:binary, [line: 60], nil}]}]}
20:27:27.246 [error] [{:board_check, 2} (Line 60)] {:<<>>, [line: 60], ["Wrong row at: ", {:"::", [line: 60], [{{:., [line: 60], [Kernel, :to_string]}, [line: 60], [{:row_number, [line: 60], nil}]}, {:binary, [line: 60], nil}]}, "  --- ", {:"::", [line: 60], [{{:., [line: 60], [Kernel, :to_string]}, [line: 60], [{:inspect, [line: 60], [{:row, [line: 60], nil}]}]}, {:binary, [line: 60], nil}]}]}
20:28:06.458 [error] [{:board_check, 2} (Line 61)] {:<<>>, [line: 61], ["Wrong row at: ", {:"::", [line: 61], [{{:., [line: 61], [Kernel, :to_string]}, [line: 61], [{:row_number, [line: 61], nil}]}, {:binary, [line: 61], nil}]}, "  --- ", {:"::", [line: 61], [{{:., [line: 61], [Kernel, :to_string]}, [line: 61], [{:inspect, [line: 61], [{:row, [line: 61], nil}]}]}, {:binary, [line: 61], nil}]}]}
20:28:06.458 [error] [{:board_check, 2} (Line 61)] {:<<>>, [line: 61], ["Wrong row at: ", {:"::", [line: 61], [{{:., [line: 61], [Kernel, :to_string]}, [line: 61], [{:row_number, [line: 61], nil}]}, {:binary, [line: 61], nil}]}, "  --- ", {:"::", [line: 61], [{{:., [line: 61], [Kernel, :to_string]}, [line: 61], [{:inspect, [line: 61], [{:row, [line: 61], nil}]}]}, {:binary, [line: 61], nil}]}]}
20:28:53.745 [error] GenServer #PID<0.1880.0> terminating
** (UndefinedFunctionError) function Chess.Game.move/2 is undefined (module Chess.Game is not available)
    (chess 0.1.0) Chess.Game.move(%{__struct__: Chess.Game, board: %{__struct__: Chess.Board, squares: [[%Chess.Square{column: :a, row: 1, loc: {1, :a}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :b, row: 1, loc: {1, :b}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :f, row: 1, loc: {1, :f}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :g, row: 1, loc: {1, :g}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}], [%Chess.Square{column: :a, row: 2, loc: {2, :a}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :b, row: 2, loc: {2, :b}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :c, row: 2, loc: {2, :c}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :g, row: 2, loc: {2, :g}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}], [%Chess.Square{column: :a, row: 3, loc: {3, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :b, row: 3, loc: {3, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :f, row: 3, loc: {3, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :g, row: 3, loc: {3, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :h, row: 3, loc: {3, :h}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}], [%Chess.Square{column: :a, row: 4, loc: {4, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :b, row: 4, loc: {4, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :d, row: 4, loc: {4, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :e, row: 4, loc: {4, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :f, row: 4, loc: {4, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :g, row: 4, loc: {4, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :h, row: 4, loc: {4, :h}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}], [%Chess.Square{column: :a, row: 5, loc: {5, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :b, row: 5, loc: {5, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :c, row: 5, loc: {5, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :d, row: 5, loc: {5, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :e, row: 5, loc: {5, :e (truncated)
20:28:54.824 [error] GenServer #PID<0.2198.0> terminating
** (UndefinedFunctionError) function Chess.Game.new/0 is undefined (module Chess.Game is not available)
    (chess 0.1.0) Chess.Game.new()
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:10: ChessWeb.Chesslive.mount/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/utils.ex:348: anonymous fn/6 in Phoenix.LiveView.Utils.maybe_call_live_view_mount!/5
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:1174: Phoenix.LiveView.Channel.verified_mount/8
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:84: Phoenix.LiveView.Channel.handle_info/2
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:241: :proc_lib.init_p_do_apply/3
Last message: {Phoenix.Channel, %{"flash" => nil, "params" => %{"_csrf_token" => "BwtCWwY8OxkHRXg8JX53NXcABAYTDgwW_Jq5eENrvs9fcK0VGkOLQTcb", "_mount_attempts" => 0, "_mounts" => 2, "_track_static" => ["http://localhost:4000/assets/app.css", "http://localhost:4000/assets/app.js"]}, "session" => "SFMyNTY.g2gDaAJhBXQAAAAIdwJpZG0AAAAUcGh4LUdEaTJ5UWxQZXBxVnpRQ0l3B3Nlc3Npb250AAAAAHcKcGFyZW50X3BpZHcDbmlsdwR2aWV3dxlFbGl4aXIuQ2hlc3NXZWIuQ2hlc3NsaXZldwhyb290X3BpZHcDbmlsdwZyb3V0ZXJ3FkVsaXhpci5DaGVzc1dlYi5Sb3V0ZXJ3DGxpdmVfc2Vzc2lvbmgCdwdkZWZhdWx0bggAy4Rp9YWFNxh3CXJvb3Rfdmlld3cZRWxpeGlyLkNoZXNzV2ViLkNoZXNzbGl2ZW4GABfdt16WAWIAAVGA.v9zw8gvV1M41IIPOzhSHe5eogoqXVBKIm6j-JGmL2ao", "static" => "SFMyNTY.g2gDaAJhBXQAAAADdwJpZG0AAAAUcGh4LUdEaTJ5UWxQZXBxVnpRQ0l3BWZsYXNodAAAAAB3CmFzc2lnbl9uZXdqbgYAF923XpYBYgABUYA.BCzkjiKKUYXTA45wozjv-m9KHNImQlGmNz4JZCcqbcA", "url" => "http://localhost:4000/chess"}, {#PID<0.1866.0>, #Reference<0.284592473.1732771843.119912>}, %Phoenix.Socket{assigns: %{}, channel: Phoenix.LiveView.Channel, channel_pid: nil, endpoint: ChessWeb.Endpoint, handler: Phoenix.LiveView.Socket, id: nil, joined: false, join_ref: "25", private: %{connect_info: %{session: %{"_csrf_token" => "XA3ncyukq6AZF5Gc0kKJBZot"}}}, pubsub_server: Chess.PubSub, ref: nil, serializer: Phoenix.Socket.V2.JSONSerializer, topic: "lv:phx-GDi2yQlPepqVzQCI", transport: :longpoll, transport_pid: #PID<0.1866.0>}}
State: #Reference<0.284592473.1732771843.119915>
20:28:54.829 [error] an exception was raised:
    ** (UndefinedFunctionError) function Chess.Game.new/0 is undefined (module Chess.Game is not available)
        (chess 0.1.0) Chess.Game.new()
        (chess 0.1.0) lib/chess_web/live/chesslive.ex:10: ChessWeb.Chesslive.mount/3
        (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/utils.ex:348: anonymous fn/6 in Phoenix.LiveView.Utils.maybe_call_live_view_mount!/5
        (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
        (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:1174: Phoenix.LiveView.Channel.verified_mount/8
        (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:84: Phoenix.LiveView.Channel.handle_info/2
        (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
        (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
        (stdlib 5.2.3.1) proc_lib.erl:241: :proc_lib.init_p_do_apply/3
20:29:05.160 [error] ** (Bandit.HTTPError) closed
20:29:07.543 [error] [{:board_check, 2} (Line 61)] {:<<>>, [line: 61], ["Wrong row at: ", {:"::", [line: 61], [{{:., [line: 61], [Kernel, :to_string]}, [line: 61], [{:row_number, [line: 61], nil}]}, {:binary, [line: 61], nil}]}, "  --- ", {:"::", [line: 61], [{{:., [line: 61], [Kernel, :to_string]}, [line: 61], [{:inspect, [line: 61], [{:row, [line: 61], nil}]}]}, {:binary, [line: 61], nil}]}]}
20:29:07.543 [error] [{:board_check, 2} (Line 61)] {:<<>>, [line: 61], ["Wrong row at: ", {:"::", [line: 61], [{{:., [line: 61], [Kernel, :to_string]}, [line: 61], [{:row_number, [line: 61], nil}]}, {:binary, [line: 61], nil}]}, "  --- ", {:"::", [line: 61], [{{:., [line: 61], [Kernel, :to_string]}, [line: 61], [{:inspect, [line: 61], [{:row, [line: 61], nil}]}]}, {:binary, [line: 61], nil}]}]}
20:33:08.439 [error] [{:board_check, 2} (Line 61)] {:<<>>, [line: 61], ["Wrong row at: ", {:"::", [line: 61], [{{:., [line: 61], [Kernel, :to_string]}, [line: 61], [{:row_number, [line: 61], nil}]}, {:binary, [line: 61], nil}]}, "  --- ", {:"::", [line: 61], [{{:., [line: 61], [Kernel, :to_string]}, [line: 61], [{:inspect, [line: 61], [{:row, [line: 61], nil}]}]}, {:binary, [line: 61], nil}]}]}
20:33:08.439 [error] [{:board_check, 2} (Line 61)] {:<<>>, [line: 61], ["Wrong row at: ", {:"::", [line: 61], [{{:., [line: 61], [Kernel, :to_string]}, [line: 61], [{:row_number, [line: 61], nil}]}, {:binary, [line: 61], nil}]}, "  --- ", {:"::", [line: 61], [{{:., [line: 61], [Kernel, :to_string]}, [line: 61], [{:inspect, [line: 61], [{:row, [line: 61], nil}]}]}, {:binary, [line: 61], nil}]}]}
20:34:30.663 [error] GenServer #PID<0.2780.0> terminating
** (FunctionClauseError) no function clause matching in Chess.Board.board_check/1
    (chess 0.1.0) lib/chess/board.ex:54: Chess.Board.board_check(:P)
    (chess 0.1.0) lib/chess/board.ex:16: Chess.Board.apply_move/2
    (chess 0.1.0) lib/chess/game.ex:16: Chess.Game.move/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:74: ChessWeb.Chesslive.handle_event/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:508: anonymous fn/3 in Phoenix.LiveView.Channel.view_handle_event/3
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:260: Phoenix.LiveView.Channel.handle_info/2
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:241: :proc_lib.init_p_do_apply/3
Last message: %Phoenix.Socket.Message{topic: "lv:phx-GDi3ueAAUX315hBB", event: "event", payload: %{"event" => "square-click", "type" => "click", "value" => %{"column" => "f", "row" => "5"}}, ref: "9", join_ref: "4"}
State: %{socket: #Phoenix.LiveView.Socket<id: "phx-GDi3ueAAUX315hBB", endpoint: ChessWeb.Endpoint, view: ChessWeb.Chesslive, parent_pid: nil, root_pid: #PID<0.2780.0>, router: ChessWeb.Router, assigns: %{__changed__: %{}, flash: %{}, live_action: nil, clicked_square: {"7", "f"}, game: %Chess.Game{board: %Chess.Board{squares: [[%Chess.Square{column: :a, row: 1, loc: {1, :a}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :b, row: 1, loc: {1, :b}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :f, row: 1, loc: {1, :f}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :g, row: 1, loc: {1, :g}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}], [%Chess.Square{column: :a, row: 2, loc: {2, :a}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :b, row: 2, loc: {2, :b}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :c, row: 2, loc: {2, :c}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :g, row: 2, loc: {2, :g}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}], [%Chess.Square{column: :a, row: 3, loc: {3, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :b, row: 3, loc: {3, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :f, row: 3, loc: {3, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :g, row: 3, loc: {3, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :h, row: 3, loc: {3, :h}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}], [%Chess.Square{column: :a, row: 4, loc: {4, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :b, row: 4, loc: {4, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :d, row: 4, loc: {4, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :e, row: 4, loc: {4, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :f, row: 4, loc: {4, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :g, row: 4, loc: {4, :g}, piece: nil, sees: %Chess.S (truncated)
20:37:38.518 [error] GenServer #PID<0.2819.0> terminating
** (FunctionClauseError) no function clause matching in Chess.Board.board_check/1
    (chess 0.1.0) lib/chess/board.ex:54: Chess.Board.board_check(:P)
    (chess 0.1.0) lib/chess/board.ex:16: Chess.Board.apply_move/2
    (chess 0.1.0) lib/chess/game.ex:16: Chess.Game.move/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:74: ChessWeb.Chesslive.handle_event/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:508: anonymous fn/3 in Phoenix.LiveView.Channel.view_handle_event/3
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:260: Phoenix.LiveView.Channel.handle_info/2
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:251: :proc_lib.wake_up/3
Last message: %Phoenix.Socket.Message{topic: "lv:phx-GDi3ueAAUX315hBB", event: "event", payload: %{"event" => "square-click", "type" => "click", "value" => %{"column" => "g", "row" => "5"}}, ref: "12", join_ref: "10"}
State: %{socket: #Phoenix.LiveView.Socket<id: "phx-GDi3ueAAUX315hBB", endpoint: ChessWeb.Endpoint, view: ChessWeb.Chesslive, parent_pid: nil, root_pid: #PID<0.2819.0>, router: ChessWeb.Router, assigns: %{__changed__: %{}, flash: %{}, live_action: nil, clicked_square: {"7", "g"}, game: %Chess.Game{board: %Chess.Board{squares: [[%Chess.Square{column: :a, row: 1, loc: {1, :a}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :b, row: 1, loc: {1, :b}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :f, row: 1, loc: {1, :f}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :g, row: 1, loc: {1, :g}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}], [%Chess.Square{column: :a, row: 2, loc: {2, :a}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :b, row: 2, loc: {2, :b}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :c, row: 2, loc: {2, :c}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :g, row: 2, loc: {2, :g}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}], [%Chess.Square{column: :a, row: 3, loc: {3, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :b, row: 3, loc: {3, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :f, row: 3, loc: {3, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :g, row: 3, loc: {3, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :h, row: 3, loc: {3, :h}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}], [%Chess.Square{column: :a, row: 4, loc: {4, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :b, row: 4, loc: {4, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :d, row: 4, loc: {4, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :e, row: 4, loc: {4, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :f, row: 4, loc: {4, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :g, row: 4, loc: {4, :g}, piece: nil, sees: %Chess.Square. (truncated)
20:20:03.038 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
20:20:15.845 [error] ** (Bandit.HTTPError) closed
20:20:19.907 [error] GenServer #PID<0.743.0> terminating
** (ArgumentError) the Access module does not support accessing lists by index, got: 1

Accessing a list by index is typically discouraged in Elixir, instead we prefer to use the Enum module to manipulate lists as a whole. If you really must access a list element by index, you can Enum.at/1 or the functions in the List module
    (elixir 1.15.7) lib/access.ex:334: Access.get/3
    (chess 0.1.0) lib/chess/game.ex:34: Chess.Game.position_to_square/3
    (chess 0.1.0) lib/chess/game.ex:17: Chess.Game.move/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:77: ChessWeb.Chesslive.handle_event/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:508: anonymous fn/3 in Phoenix.LiveView.Channel.view_handle_event/3
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:260: Phoenix.LiveView.Channel.handle_info/2
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:241: :proc_lib.init_p_do_apply/3
Last message: %Phoenix.Socket.Message{topic: "lv:phx-GDlUHVs9rSYHNgJD", event: "event", payload: %{"event" => "square-click", "type" => "click", "value" => %{"column" => "e", "row" => "4"}}, ref: "13", join_ref: "4"}
State: %{socket: #Phoenix.LiveView.Socket<id: "phx-GDlUHVs9rSYHNgJD", endpoint: ChessWeb.Endpoint, view: ChessWeb.Chesslive, parent_pid: nil, root_pid: #PID<0.743.0>, router: ChessWeb.Router, assigns: %{__changed__: %{}, flash: %{}, game: %Chess.Game{board: %Chess.Board{squares: [[%Chess.Square{column: :a, row: 1, loc: {1, :a}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :b, row: 1, loc: {1, :b}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :f, row: 1, loc: {1, :f}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :g, row: 1, loc: {1, :g}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}], [%Chess.Square{column: :a, row: 2, loc: {2, :a}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :b, row: 2, loc: {2, :b}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :c, row: 2, loc: {2, :c}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :g, row: 2, loc: {2, :g}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}], [%Chess.Square{column: :a, row: 3, loc: {3, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :b, row: 3, loc: {3, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :f, row: 3, loc: {3, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :g, row: 3, loc: {3, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :h, row: 3, loc: {3, :h}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}], [%Chess.Square{column: :a, row: 4, loc: {4, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :b, row: 4, loc: {4, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :d, row: 4, loc: {4, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :e, row: 4, loc: {4, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :f, row: 4, loc: {4, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [],  (truncated)
20:21:17.226 [error] GenServer #PID<0.787.0> terminating
** (KeyError) key :board not found in: {:error, "black turn"}

If you are using the dot syntax, such as map.field, make sure the left-hand side of the dot is a map
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:16: ChessWeb.Chesslive.render/1
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/renderer.ex:79: Phoenix.LiveView.Renderer.to_rendered/2
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:959: anonymous fn/4 in Phoenix.LiveView.Channel.render_diff/3
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:955: Phoenix.LiveView.Channel.render_diff/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:811: Phoenix.LiveView.Channel.handle_changed/4
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:241: :proc_lib.init_p_do_apply/3
Last message: %Phoenix.Socket.Message{topic: "lv:phx-GDlUKzmkEA0HNgAk", event: "event", payload: %{"event" => "square-click", "type" => "click", "value" => %{"column" => "e", "row" => "4"}}, ref: "13", join_ref: "4"}
State: %{socket: #Phoenix.LiveView.Socket<id: "phx-GDlUKzmkEA0HNgAk", endpoint: ChessWeb.Endpoint, view: ChessWeb.Chesslive, parent_pid: nil, root_pid: #PID<0.787.0>, router: ChessWeb.Router, assigns: %{__changed__: %{}, flash: %{}, game: %Chess.Game{board: %Chess.Board{squares: [[%Chess.Square{column: :a, row: 1, loc: {1, :a}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :b, row: 1, loc: {1, :b}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :f, row: 1, loc: {1, :f}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :g, row: 1, loc: {1, :g}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}], [%Chess.Square{column: :a, row: 2, loc: {2, :a}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :b, row: 2, loc: {2, :b}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :c, row: 2, loc: {2, :c}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :g, row: 2, loc: {2, :g}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}], [%Chess.Square{column: :a, row: 3, loc: {3, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :b, row: 3, loc: {3, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :f, row: 3, loc: {3, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :g, row: 3, loc: {3, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :h, row: 3, loc: {3, :h}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}], [%Chess.Square{column: :a, row: 4, loc: {4, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :b, row: 4, loc: {4, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :d, row: 4, loc: {4, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :e, row: 4, loc: {4, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :f, row: 4, loc: {4, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{co (truncated)
20:27:01.429 [error] ** (Bandit.HTTPError) closed
20:35:34.975 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
18:32:53.037 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
16:06:53.380 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
16:06:59.668 [error] ** (Bandit.HTTPError) closed
16:07:02.617 [error] ** (ArgumentError) argument error
    (stdlib 5.2.3.1) :maps.from_list([%Chess.Square{column: :a, row: 2, loc: {2, :a}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :b, row: 2, loc: {2, :b}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :c, row: 2, loc: {2, :c}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :g, row: 2, loc: {2, :g}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}])
    (chess 0.1.0) lib/chess/board.ex:90: Chess.Board.create_pawns/3
    (chess 0.1.0) lib/chess/board.ex:73: Chess.Board.initiate_board/0
    (chess 0.1.0) lib/chess/game.ex:12: Chess.Game.new/0
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:11: ChessWeb.Chesslive.mount/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/utils.ex:348: anonymous fn/6 in Phoenix.LiveView.Utils.maybe_call_live_view_mount!/5
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/static.ex:320: Phoenix.LiveView.Static.call_mount_and_handle_params!/5
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/static.ex:155: Phoenix.LiveView.Static.do_render/4
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/controller.ex:39: Phoenix.LiveView.Controller.live_render/3
    (phoenix 1.7.14) lib/phoenix/router.ex:484: Phoenix.Router.__call__/5
    (chess 0.1.0) lib/chess_web/endpoint.ex:1: ChessWeb.Endpoint.plug_builder_call/2
    (chess 0.1.0) deps/plug/lib/plug/debugger.ex:136: ChessWeb.Endpoint."call (overridable 3)"/2
    (chess 0.1.0) lib/chess_web/endpoint.ex:1: ChessWeb.Endpoint.call/2
    (phoenix 1.7.14) lib/phoenix/endpoint/sync_code_reload_plug.ex:22: Phoenix.Endpoint.SyncCodeReloadPlug.do_call/4
    (bandit 1.5.7) lib/bandit/pipeline.ex:124: Bandit.Pipeline.call_plug!/2
    (bandit 1.5.7) lib/bandit/pipeline.ex:36: Bandit.Pipeline.run/4
    (bandit 1.5.7) lib/bandit/http1/handler.ex:12: Bandit.HTTP1.Handler.handle_data/3
    (bandit 1.5.7) lib/bandit/delegating_handler.ex:18: Bandit.DelegatingHandler.handle_data/3
    (bandit 1.5.7) /home/gikes/Projects/Elixir/chess_live/chess/deps/thousand_island/lib/thousand_island/handler.ex:411: Bandit.DelegatingHandler.handle_continue/2

16:07:02.718 [error] ** (Bandit.HTTPError) closed
16:08:26.662 [error] ** (KeyError) key :column not found in: nil

If you are using the dot syntax, such as map.field, make sure the left-hand side of the dot is a map
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:66: anonymous fn/3 in ChessWeb.Chesslive."square (overridable 1)"/1
    (chess 0.1.0) /home/gikes/Projects/Elixir/chess_live/chess/lib/chess_web/live/chesslive.ex:23: ChessWeb.Chesslive.render/1
    (elixir 1.15.7) lib/enum.ex:1819: Enum."-map_reduce/3-lists^mapfoldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:493: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:582: anonymous fn/3 in Phoenix.LiveView.Diff.traverse_comprehension/5
    (elixir 1.15.7) lib/enum.ex:1819: Enum."-map_reduce/3-lists^mapfoldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:503: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:555: anonymous fn/4 in Phoenix.LiveView.Diff.traverse_dynamic/7
    (elixir 1.15.7) lib/enum.ex:2510: Enum."-reduce/3-lists^foldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:412: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:555: anonymous fn/4 in Phoenix.LiveView.Diff.traverse_dynamic/7
    (elixir 1.15.7) lib/enum.ex:2510: Enum."-reduce/3-lists^foldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:412: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:136: Phoenix.LiveView.Diff.render/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/static.ex:288: Phoenix.LiveView.Static.to_rendered_content_tag/4
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/static.ex:171: Phoenix.LiveView.Static.do_render/4
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/controller.ex:39: Phoenix.LiveView.Controller.live_render/3
    (phoenix 1.7.14) lib/phoenix/router.ex:484: Phoenix.Router.__call__/5

16:08:26.830 [error] ** (Bandit.HTTPError) closed
16:15:28.745 [error] ** (KeyError) key :column not found in: nil

If you are using the dot syntax, such as map.field, make sure the left-hand side of the dot is a map
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:68: anonymous fn/3 in ChessWeb.Chesslive."square (overridable 1)"/1
    (chess 0.1.0) /home/gikes/Projects/Elixir/chess_live/chess/lib/chess_web/live/chesslive.ex:25: ChessWeb.Chesslive.render/1
    (elixir 1.15.7) lib/enum.ex:1819: Enum."-map_reduce/3-lists^mapfoldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:493: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:582: anonymous fn/3 in Phoenix.LiveView.Diff.traverse_comprehension/5
    (elixir 1.15.7) lib/enum.ex:1819: Enum."-map_reduce/3-lists^mapfoldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:503: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:555: anonymous fn/4 in Phoenix.LiveView.Diff.traverse_dynamic/7
    (elixir 1.15.7) lib/enum.ex:2510: Enum."-reduce/3-lists^foldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:412: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:555: anonymous fn/4 in Phoenix.LiveView.Diff.traverse_dynamic/7
    (elixir 1.15.7) lib/enum.ex:2510: Enum."-reduce/3-lists^foldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:412: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:136: Phoenix.LiveView.Diff.render/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/static.ex:288: Phoenix.LiveView.Static.to_rendered_content_tag/4
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/static.ex:171: Phoenix.LiveView.Static.do_render/4
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/controller.ex:39: Phoenix.LiveView.Controller.live_render/3
    (phoenix 1.7.14) lib/phoenix/router.ex:484: Phoenix.Router.__call__/5

16:16:36.012 [error] ** (KeyError) key :column not found in: nil

If you are using the dot syntax, such as map.field, make sure the left-hand side of the dot is a map
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:68: anonymous fn/3 in ChessWeb.Chesslive."square (overridable 1)"/1
    (chess 0.1.0) /home/gikes/Projects/Elixir/chess_live/chess/lib/chess_web/live/chesslive.ex:25: ChessWeb.Chesslive.render/1
    (elixir 1.15.7) lib/enum.ex:1819: Enum."-map_reduce/3-lists^mapfoldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:493: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:582: anonymous fn/3 in Phoenix.LiveView.Diff.traverse_comprehension/5
    (elixir 1.15.7) lib/enum.ex:1819: Enum."-map_reduce/3-lists^mapfoldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:503: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:555: anonymous fn/4 in Phoenix.LiveView.Diff.traverse_dynamic/7
    (elixir 1.15.7) lib/enum.ex:2510: Enum."-reduce/3-lists^foldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:412: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:555: anonymous fn/4 in Phoenix.LiveView.Diff.traverse_dynamic/7
    (elixir 1.15.7) lib/enum.ex:2510: Enum."-reduce/3-lists^foldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:412: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:136: Phoenix.LiveView.Diff.render/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/static.ex:288: Phoenix.LiveView.Static.to_rendered_content_tag/4
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/static.ex:171: Phoenix.LiveView.Static.do_render/4
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/controller.ex:39: Phoenix.LiveView.Controller.live_render/3
    (phoenix 1.7.14) lib/phoenix/router.ex:484: Phoenix.Router.__call__/5

16:16:53.139 [error] ** (KeyError) key :column not found in: nil

If you are using the dot syntax, such as map.field, make sure the left-hand side of the dot is a map
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:66: anonymous fn/3 in ChessWeb.Chesslive."square (overridable 1)"/1
    (chess 0.1.0) /home/gikes/Projects/Elixir/chess_live/chess/lib/chess_web/live/chesslive.ex:23: ChessWeb.Chesslive.render/1
    (elixir 1.15.7) lib/enum.ex:1819: Enum."-map_reduce/3-lists^mapfoldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:493: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:582: anonymous fn/3 in Phoenix.LiveView.Diff.traverse_comprehension/5
    (elixir 1.15.7) lib/enum.ex:1819: Enum."-map_reduce/3-lists^mapfoldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:503: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:555: anonymous fn/4 in Phoenix.LiveView.Diff.traverse_dynamic/7
    (elixir 1.15.7) lib/enum.ex:2510: Enum."-reduce/3-lists^foldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:412: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:555: anonymous fn/4 in Phoenix.LiveView.Diff.traverse_dynamic/7
    (elixir 1.15.7) lib/enum.ex:2510: Enum."-reduce/3-lists^foldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:412: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:136: Phoenix.LiveView.Diff.render/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/static.ex:288: Phoenix.LiveView.Static.to_rendered_content_tag/4
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/static.ex:171: Phoenix.LiveView.Static.do_render/4
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/controller.ex:39: Phoenix.LiveView.Controller.live_render/3
    (phoenix 1.7.14) lib/phoenix/router.ex:484: Phoenix.Router.__call__/5

16:23:07.958 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
16:23:16.701 [error] ** (KeyError) key :column not found in: nil

If you are using the dot syntax, such as map.field, make sure the left-hand side of the dot is a map
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:66: anonymous fn/3 in ChessWeb.Chesslive."square (overridable 1)"/1
    (chess 0.1.0) /home/gikes/Projects/Elixir/chess_live/chess/lib/chess_web/live/chesslive.ex:23: ChessWeb.Chesslive.render/1
    (elixir 1.15.7) lib/enum.ex:1819: Enum."-map_reduce/3-lists^mapfoldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:493: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:582: anonymous fn/3 in Phoenix.LiveView.Diff.traverse_comprehension/5
    (elixir 1.15.7) lib/enum.ex:1819: Enum."-map_reduce/3-lists^mapfoldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:503: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:555: anonymous fn/4 in Phoenix.LiveView.Diff.traverse_dynamic/7
    (elixir 1.15.7) lib/enum.ex:2510: Enum."-reduce/3-lists^foldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:412: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:555: anonymous fn/4 in Phoenix.LiveView.Diff.traverse_dynamic/7
    (elixir 1.15.7) lib/enum.ex:2510: Enum."-reduce/3-lists^foldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:412: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:136: Phoenix.LiveView.Diff.render/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/static.ex:288: Phoenix.LiveView.Static.to_rendered_content_tag/4
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/static.ex:171: Phoenix.LiveView.Static.do_render/4
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/controller.ex:39: Phoenix.LiveView.Controller.live_render/3
    (phoenix 1.7.14) lib/phoenix/router.ex:484: Phoenix.Router.__call__/5

16:24:12.901 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
16:24:17.171 [error] ** (KeyError) key :column not found in: nil

If you are using the dot syntax, such as map.field, make sure the left-hand side of the dot is a map
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:66: anonymous fn/3 in ChessWeb.Chesslive."square (overridable 1)"/1
    (chess 0.1.0) /home/gikes/Projects/Elixir/chess_live/chess/lib/chess_web/live/chesslive.ex:23: ChessWeb.Chesslive.render/1
    (elixir 1.15.7) lib/enum.ex:1819: Enum."-map_reduce/3-lists^mapfoldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:493: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:582: anonymous fn/3 in Phoenix.LiveView.Diff.traverse_comprehension/5
    (elixir 1.15.7) lib/enum.ex:1819: Enum."-map_reduce/3-lists^mapfoldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:503: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:555: anonymous fn/4 in Phoenix.LiveView.Diff.traverse_dynamic/7
    (elixir 1.15.7) lib/enum.ex:2510: Enum."-reduce/3-lists^foldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:412: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:555: anonymous fn/4 in Phoenix.LiveView.Diff.traverse_dynamic/7
    (elixir 1.15.7) lib/enum.ex:2510: Enum."-reduce/3-lists^foldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:412: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:136: Phoenix.LiveView.Diff.render/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/static.ex:288: Phoenix.LiveView.Static.to_rendered_content_tag/4
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/static.ex:171: Phoenix.LiveView.Static.do_render/4
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/controller.ex:39: Phoenix.LiveView.Controller.live_render/3
    (phoenix 1.7.14) lib/phoenix/router.ex:484: Phoenix.Router.__call__/5

16:27:41.981 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
16:27:47.472 [error] ** (KeyError) key :column not found in: nil

If you are using the dot syntax, such as map.field, make sure the left-hand side of the dot is a map
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:66: anonymous fn/3 in ChessWeb.Chesslive."square (overridable 1)"/1
    (chess 0.1.0) /home/gikes/Projects/Elixir/chess_live/chess/lib/chess_web/live/chesslive.ex:23: ChessWeb.Chesslive.render/1
    (elixir 1.15.7) lib/enum.ex:1819: Enum."-map_reduce/3-lists^mapfoldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:493: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:582: anonymous fn/3 in Phoenix.LiveView.Diff.traverse_comprehension/5
    (elixir 1.15.7) lib/enum.ex:1819: Enum."-map_reduce/3-lists^mapfoldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:503: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:555: anonymous fn/4 in Phoenix.LiveView.Diff.traverse_dynamic/7
    (elixir 1.15.7) lib/enum.ex:2510: Enum."-reduce/3-lists^foldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:412: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:555: anonymous fn/4 in Phoenix.LiveView.Diff.traverse_dynamic/7
    (elixir 1.15.7) lib/enum.ex:2510: Enum."-reduce/3-lists^foldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:412: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:136: Phoenix.LiveView.Diff.render/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/static.ex:288: Phoenix.LiveView.Static.to_rendered_content_tag/4
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/static.ex:171: Phoenix.LiveView.Static.do_render/4
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/controller.ex:39: Phoenix.LiveView.Controller.live_render/3
    (phoenix 1.7.14) lib/phoenix/router.ex:484: Phoenix.Router.__call__/5

16:30:39.989 [error] ** (KeyError) key :row not found in: nil

If you are using the dot syntax, such as map.field, make sure the left-hand side of the dot is a map
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:59: ChessWeb.Chesslive."square (overridable 1)"/1
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/tag_engine.ex:92: Phoenix.LiveView.TagEngine.component/3
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:23: anonymous fn/6 in ChessWeb.Chesslive.render/1
    (elixir 1.15.7) lib/enum.ex:2510: Enum."-reduce/3-lists^foldl/2-0-"/3
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:22: anonymous fn/4 in ChessWeb.Chesslive.render/1
    (elixir 1.15.7) lib/enum.ex:4356: Enum.map/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:20: anonymous fn/3 in ChessWeb.Chesslive.render/1
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:414: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:555: anonymous fn/4 in Phoenix.LiveView.Diff.traverse_dynamic/7
    (elixir 1.15.7) lib/enum.ex:2510: Enum."-reduce/3-lists^foldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:412: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:136: Phoenix.LiveView.Diff.render/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/static.ex:288: Phoenix.LiveView.Static.to_rendered_content_tag/4
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/static.ex:171: Phoenix.LiveView.Static.do_render/4
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/controller.ex:39: Phoenix.LiveView.Controller.live_render/3
    (phoenix 1.7.14) lib/phoenix/router.ex:484: Phoenix.Router.__call__/5
    (chess 0.1.0) lib/chess_web/endpoint.ex:1: ChessWeb.Endpoint.plug_builder_call/2
    (chess 0.1.0) deps/plug/lib/plug/debugger.ex:136: ChessWeb.Endpoint."call (overridable 3)"/2
    (chess 0.1.0) lib/chess_web/endpoint.ex:1: ChessWeb.Endpoint.call/2
    (phoenix 1.7.14) lib/phoenix/endpoint/sync_code_reload_plug.ex:22: Phoenix.Endpoint.SyncCodeReloadPlug.do_call/4

16:31:47.853 [error] ** (KeyError) key :row not found in: %{
  square: nil,
  __changed__: nil,
  row_index: 1,
  col_index: 1,
  __given__: %{square: nil, __changed__: nil, row_index: 1, col_index: 1}
}
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:59: ChessWeb.Chesslive."square (overridable 1)"/1
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/tag_engine.ex:92: Phoenix.LiveView.TagEngine.component/3
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:23: anonymous fn/6 in ChessWeb.Chesslive.render/1
    (elixir 1.15.7) lib/enum.ex:2510: Enum."-reduce/3-lists^foldl/2-0-"/3
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:22: anonymous fn/4 in ChessWeb.Chesslive.render/1
    (elixir 1.15.7) lib/enum.ex:4356: Enum.map/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:20: anonymous fn/3 in ChessWeb.Chesslive.render/1
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:414: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:555: anonymous fn/4 in Phoenix.LiveView.Diff.traverse_dynamic/7
    (elixir 1.15.7) lib/enum.ex:2510: Enum."-reduce/3-lists^foldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:412: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:136: Phoenix.LiveView.Diff.render/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/static.ex:288: Phoenix.LiveView.Static.to_rendered_content_tag/4
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/static.ex:171: Phoenix.LiveView.Static.do_render/4
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/controller.ex:39: Phoenix.LiveView.Controller.live_render/3
    (phoenix 1.7.14) lib/phoenix/router.ex:484: Phoenix.Router.__call__/5
    (chess 0.1.0) lib/chess_web/endpoint.ex:1: ChessWeb.Endpoint.plug_builder_call/2
    (chess 0.1.0) deps/plug/lib/plug/debugger.ex:136: ChessWeb.Endpoint."call (overridable 3)"/2
    (chess 0.1.0) lib/chess_web/endpoint.ex:1: ChessWeb.Endpoint.call/2
    (phoenix 1.7.14) lib/phoenix/endpoint/sync_code_reload_plug.ex:22: Phoenix.Endpoint.SyncCodeReloadPlug.do_call/4

16:31:47.994 [error] ** (Bandit.HTTPError) closed
16:34:10.018 [error] ** (KeyError) key :row not found in: %{
  square: %Chess.Square{
    column: :a,
    row: 1,
    loc: {1, :a},
    piece: :r,
    sees: %Chess.Square.Sees{
      up: [],
      down: [],
      left: [],
      right: [],
      up_right: [],
      up_left: [],
      down_left: [],
      down_right: [],
      knight: [],
      all: MapSet.new([])
    }
  },
  __changed__: nil,
  row_index: 1,
  col_index: 1,
  __given__: %{
    square: %Chess.Square{
      column: :a,
      row: 1,
      loc: {1, :a},
      piece: :r,
      sees: %Chess.Square.Sees{
        up: [],
        down: [],
        left: [],
        right: [],
        up_right: [],
        up_left: [],
        down_left: [],
        down_right: [],
        knight: [],
        all: MapSet.new([])
      }
    },
    __changed__: nil,
    row_index: 1,
    col_index: 1
  }
}
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:59: ChessWeb.Chesslive."square (overridable 1)"/1
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/tag_engine.ex:92: Phoenix.LiveView.TagEngine.component/3
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:23: anonymous fn/6 in ChessWeb.Chesslive.render/1
    (elixir 1.15.7) lib/enum.ex:2510: Enum."-reduce/3-lists^foldl/2-0-"/3
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:22: anonymous fn/4 in ChessWeb.Chesslive.render/1
    (elixir 1.15.7) lib/enum.ex:4356: Enum.map/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:20: anonymous fn/3 in ChessWeb.Chesslive.render/1
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:414: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:555: anonymous fn/4 in Phoenix.LiveView.Diff.traverse_dynamic/7
    (elixir 1.15.7) lib/enum.ex:2510: Enum."-reduce/3-lists^foldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:412: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:136: Phoenix.LiveView.Diff.render/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/static.ex:288: Phoenix.LiveView.Static.to_rendered_content_tag/4
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/static.ex:171: Phoenix.LiveView.Static.do_render/4
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/controller.ex:39: Phoenix.LiveView.Controller.live_render/3
    (phoenix 1.7.14) lib/phoenix/router.ex:484: Phoenix.Router.__call__/5
    (chess 0.1.0) lib/chess_web/endpoint.ex:1: ChessWeb.Endpoint.plug_builder_call/2
    (chess 0.1.0) deps/plug/lib/plug/debugger.ex:136: ChessWeb.Endpoint."call (overridable 3)"/2
    (chess 0.1.0) lib/chess_web/endpoint.ex:1: ChessWeb.Endpoint.call/2
    (phoenix 1.7.14) lib/phoenix/endpoint/sync_code_reload_plug.ex:22: Phoenix.Endpoint.SyncCodeReloadPlug.do_call/4

16:34:58.448 [error] ** (Bandit.HTTPError) closed
21:56:08.862 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
22:01:50.100 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
22:01:54.763 [error] ** (Bandit.HTTPError) closed
22:03:11.073 [error] ** (Bandit.HTTPError) closed
22:03:17.211 [error] GenServer #PID<0.852.0> terminating
** (MatchError) no match of right hand side value: {:error, :empty_square}
    (chess 0.1.0) lib/chess/board.ex:15: Chess.Board.apply_move/2
    (chess 0.1.0) lib/chess/game.ex:20: Chess.Game.move/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:76: ChessWeb.Chesslive.handle_event/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:508: anonymous fn/3 in Phoenix.LiveView.Channel.view_handle_event/3
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:260: Phoenix.LiveView.Channel.handle_info/2
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:241: :proc_lib.init_p_do_apply/3
Last message: %Phoenix.Socket.Message{topic: "lv:phx-GEEGPU3BTGfzVAAj", event: "event", payload: %{"event" => "square-click", "type" => "click", "value" => %{"column" => "e", "row" => "4"}}, ref: "15", join_ref: "4"}
State: %{socket: #Phoenix.LiveView.Socket<id: "phx-GEEGPU3BTGfzVAAj", endpoint: ChessWeb.Endpoint, view: ChessWeb.Chesslive, parent_pid: nil, root_pid: #PID<0.852.0>, router: ChessWeb.Router, assigns: %{__changed__: %{}, flash: %{}, game: %Chess.Game{board: %Chess.Board{squares: %{{3, :c} => %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :c} => %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :b} => %Chess.Square{column: :b, row: 6, loc: {6, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :d} => %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :c} => %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :g} => %Chess.Square{column: :g, row: 2, loc: {2, :g}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :g} => %Chess.Square{column: :g, row: 3, loc: {3, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :h} => %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :e} => %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :b} => %Chess.Square{column: :b, row: 5, loc: {5, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :f} => %Chess.Square{column: :f, row: 3, loc: {3, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :f} => %Chess.Square{column: :f, row: 4, loc: {4, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :d} => %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :a} => %Chess.Square{column: :a, row: 8, loc: {8, :a}, piece: :R, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :f} => %Chess.Square{column: :f, row: 1, loc: {1, :f}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :f} => %Chess.Square{column: :f, row: 6, loc: {6, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :g} => %Chess.Square{column: :g, row: 1, loc: {1, :g}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :e} => %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :h} => %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :e} => %Chess.Square{column: :e, row: 5, loc: {5, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :d} => %Chess.Square{column: :d, row: 6, loc: {6, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :g} => %Chess.Square{column: :g, row: 5, loc: {5, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :d} => %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], ...}}, {2, :f} => %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], ...}}, {2, :e} => %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], ...}}, {7, :e} => %Chess.Square{column: :e, row: 7, loc: {7, :e}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], ...}}, {7, :f} => %Chess.Square{column: :f, row: 7, loc: {7, :f}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], ...}}, {7, :c} => %Chess.Square{column: :c, row: 7, loc: {7, :c}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], ...}}, {8, :h} => %Chess.Square{column: :h, row: 8, loc: {8, :h}, piece: :R, sees: %Chess.Square.Sees{up: [], down: [], left: [], ...}}, {2, :c} => %Chess.Square{column: :c, row: 2, loc: {2, :c}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], ...}}, {4, :h} => %Chess.Square{column: :h, row: 4, loc: {4, :h}, piece: nil, sees: %Chess.Square.Sees{up: [], ...}}, {8, :d} => %Chess.Square{column: :d, row: 8, loc: {8, :d}, piece: :Q, sees: %Chess.Square.Sees{...}}, {7, :a} => %Chess.Square{column: :a, row: 7, loc: {7, ...}, piece: :P, ...}, {1, :a} => %Chess.Square{column: :a, row: 1, loc: {...}, ...}, {7, :h} => %Chess.Square{colum (truncated)
22:03:33.858 [error] GenServer #PID<0.855.0> terminating
** (MatchError) no match of right hand side value: {:error, :empty_square}
    (chess 0.1.0) lib/chess/board.ex:15: Chess.Board.apply_move/2
    (chess 0.1.0) lib/chess/game.ex:20: Chess.Game.move/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:76: ChessWeb.Chesslive.handle_event/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:508: anonymous fn/3 in Phoenix.LiveView.Channel.view_handle_event/3
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:260: Phoenix.LiveView.Channel.handle_info/2
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:241: :proc_lib.init_p_do_apply/3
Last message: %Phoenix.Socket.Message{topic: "lv:phx-GEEGPU3BTGfzVAAj", event: "event", payload: %{"event" => "square-click", "type" => "click", "value" => %{"column" => "e", "row" => "4"}}, ref: "20", join_ref: "16"}
State: %{socket: #Phoenix.LiveView.Socket<id: "phx-GEEGPU3BTGfzVAAj", endpoint: ChessWeb.Endpoint, view: ChessWeb.Chesslive, parent_pid: nil, root_pid: #PID<0.855.0>, router: ChessWeb.Router, assigns: %{__changed__: %{}, flash: %{}, game: %Chess.Game{board: %Chess.Board{squares: %{{3, :c} => %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :c} => %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :b} => %Chess.Square{column: :b, row: 6, loc: {6, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :d} => %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :c} => %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :g} => %Chess.Square{column: :g, row: 2, loc: {2, :g}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :g} => %Chess.Square{column: :g, row: 3, loc: {3, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :h} => %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :e} => %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :b} => %Chess.Square{column: :b, row: 5, loc: {5, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :f} => %Chess.Square{column: :f, row: 3, loc: {3, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :f} => %Chess.Square{column: :f, row: 4, loc: {4, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :d} => %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :a} => %Chess.Square{column: :a, row: 8, loc: {8, :a}, piece: :R, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :f} => %Chess.Square{column: :f, row: 1, loc: {1, :f}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :f} => %Chess.Square{column: :f, row: 6, loc: {6, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :g} => %Chess.Square{column: :g, row: 1, loc: {1, :g}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :e} => %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :h} => %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :e} => %Chess.Square{column: :e, row: 5, loc: {5, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :d} => %Chess.Square{column: :d, row: 6, loc: {6, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :g} => %Chess.Square{column: :g, row: 5, loc: {5, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :d} => %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], ...}}, {2, :f} => %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], ...}}, {2, :e} => %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], ...}}, {7, :e} => %Chess.Square{column: :e, row: 7, loc: {7, :e}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], ...}}, {7, :f} => %Chess.Square{column: :f, row: 7, loc: {7, :f}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], ...}}, {7, :c} => %Chess.Square{column: :c, row: 7, loc: {7, :c}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], ...}}, {8, :h} => %Chess.Square{column: :h, row: 8, loc: {8, :h}, piece: :R, sees: %Chess.Square.Sees{up: [], down: [], left: [], ...}}, {2, :c} => %Chess.Square{column: :c, row: 2, loc: {2, :c}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], ...}}, {4, :h} => %Chess.Square{column: :h, row: 4, loc: {4, :h}, piece: nil, sees: %Chess.Square.Sees{up: [], ...}}, {8, :d} => %Chess.Square{column: :d, row: 8, loc: {8, :d}, piece: :Q, sees: %Chess.Square.Sees{...}}, {7, :a} => %Chess.Square{column: :a, row: 7, loc: {7, ...}, piece: :P, ...}, {1, :a} => %Chess.Square{column: :a, row: 1, loc: {...}, ...}, {7, :h} => %Chess.Square{colu (truncated)
22:04:07.961 [error] ** (Bandit.HTTPError) closed
22:04:16.172 [error] GenServer #PID<0.886.0> terminating
** (MatchError) no match of right hand side value: {:error, :empty_square}
    (chess 0.1.0) lib/chess/board.ex:15: Chess.Board.apply_move/2
    (chess 0.1.0) lib/chess/game.ex:20: Chess.Game.move/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:76: ChessWeb.Chesslive.handle_event/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:508: anonymous fn/3 in Phoenix.LiveView.Channel.view_handle_event/3
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:260: Phoenix.LiveView.Channel.handle_info/2
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:241: :proc_lib.init_p_do_apply/3
Last message: %Phoenix.Socket.Message{topic: "lv:phx-GEEGSphlHLfzVAQC", event: "event", payload: %{"event" => "square-click", "type" => "click", "value" => %{"column" => "g", "row" => "5"}}, ref: "15", join_ref: "4"}
State: %{socket: #Phoenix.LiveView.Socket<id: "phx-GEEGSphlHLfzVAQC", endpoint: ChessWeb.Endpoint, view: ChessWeb.Chesslive, parent_pid: nil, root_pid: #PID<0.886.0>, router: ChessWeb.Router, assigns: %{__changed__: %{}, flash: %{}, game: %Chess.Game{board: %Chess.Board{squares: %{{3, :c} => %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :c} => %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :b} => %Chess.Square{column: :b, row: 6, loc: {6, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :d} => %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :c} => %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :g} => %Chess.Square{column: :g, row: 2, loc: {2, :g}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :g} => %Chess.Square{column: :g, row: 3, loc: {3, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :h} => %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :e} => %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :b} => %Chess.Square{column: :b, row: 5, loc: {5, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :f} => %Chess.Square{column: :f, row: 3, loc: {3, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :f} => %Chess.Square{column: :f, row: 4, loc: {4, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :d} => %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :a} => %Chess.Square{column: :a, row: 8, loc: {8, :a}, piece: :R, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :f} => %Chess.Square{column: :f, row: 1, loc: {1, :f}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :f} => %Chess.Square{column: :f, row: 6, loc: {6, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :g} => %Chess.Square{column: :g, row: 1, loc: {1, :g}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :e} => %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :h} => %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :e} => %Chess.Square{column: :e, row: 5, loc: {5, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :d} => %Chess.Square{column: :d, row: 6, loc: {6, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :g} => %Chess.Square{column: :g, row: 5, loc: {5, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :d} => %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], ...}}, {2, :f} => %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], ...}}, {2, :e} => %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], ...}}, {7, :e} => %Chess.Square{column: :e, row: 7, loc: {7, :e}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], ...}}, {7, :f} => %Chess.Square{column: :f, row: 7, loc: {7, :f}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], ...}}, {7, :c} => %Chess.Square{column: :c, row: 7, loc: {7, :c}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], ...}}, {8, :h} => %Chess.Square{column: :h, row: 8, loc: {8, :h}, piece: :R, sees: %Chess.Square.Sees{up: [], down: [], left: [], ...}}, {2, :c} => %Chess.Square{column: :c, row: 2, loc: {2, :c}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], ...}}, {4, :h} => %Chess.Square{column: :h, row: 4, loc: {4, :h}, piece: nil, sees: %Chess.Square.Sees{up: [], ...}}, {8, :d} => %Chess.Square{column: :d, row: 8, loc: {8, :d}, piece: :Q, sees: %Chess.Square.Sees{...}}, {7, :a} => %Chess.Square{column: :a, row: 7, loc: {7, ...}, piece: :P, ...}, {1, :a} => %Chess.Square{column: :a, row: 1, loc: {...}, ...}, {7, :h} => %Chess.Square{colum (truncated)
22:04:26.672 [error] GenServer #PID<0.890.0> terminating
** (MatchError) no match of right hand side value: {:error, :empty_square}
    (chess 0.1.0) lib/chess/board.ex:15: Chess.Board.apply_move/2
    (chess 0.1.0) lib/chess/game.ex:20: Chess.Game.move/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:76: ChessWeb.Chesslive.handle_event/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:508: anonymous fn/3 in Phoenix.LiveView.Channel.view_handle_event/3
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:260: Phoenix.LiveView.Channel.handle_info/2
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:241: :proc_lib.init_p_do_apply/3
Last message: %Phoenix.Socket.Message{topic: "lv:phx-GEEGSphlHLfzVAQC", event: "event", payload: %{"event" => "square-click", "type" => "click", "value" => %{"column" => "f", "row" => "5"}}, ref: "18", join_ref: "16"}
State: %{socket: #Phoenix.LiveView.Socket<id: "phx-GEEGSphlHLfzVAQC", endpoint: ChessWeb.Endpoint, view: ChessWeb.Chesslive, parent_pid: nil, root_pid: #PID<0.890.0>, router: ChessWeb.Router, assigns: %{__changed__: %{}, flash: %{}, game: %Chess.Game{board: %Chess.Board{squares: %{{3, :c} => %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :c} => %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :b} => %Chess.Square{column: :b, row: 6, loc: {6, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :d} => %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :c} => %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :g} => %Chess.Square{column: :g, row: 2, loc: {2, :g}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :g} => %Chess.Square{column: :g, row: 3, loc: {3, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :h} => %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :e} => %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :b} => %Chess.Square{column: :b, row: 5, loc: {5, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :f} => %Chess.Square{column: :f, row: 3, loc: {3, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :f} => %Chess.Square{column: :f, row: 4, loc: {4, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :d} => %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :a} => %Chess.Square{column: :a, row: 8, loc: {8, :a}, piece: :R, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :f} => %Chess.Square{column: :f, row: 1, loc: {1, :f}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :f} => %Chess.Square{column: :f, row: 6, loc: {6, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :g} => %Chess.Square{column: :g, row: 1, loc: {1, :g}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :e} => %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :h} => %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :e} => %Chess.Square{column: :e, row: 5, loc: {5, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :d} => %Chess.Square{column: :d, row: 6, loc: {6, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :g} => %Chess.Square{column: :g, row: 5, loc: {5, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :d} => %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], ...}}, {2, :f} => %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], ...}}, {2, :e} => %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], ...}}, {7, :e} => %Chess.Square{column: :e, row: 7, loc: {7, :e}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], ...}}, {7, :f} => %Chess.Square{column: :f, row: 7, loc: {7, :f}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], ...}}, {7, :c} => %Chess.Square{column: :c, row: 7, loc: {7, :c}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], ...}}, {8, :h} => %Chess.Square{column: :h, row: 8, loc: {8, :h}, piece: :R, sees: %Chess.Square.Sees{up: [], down: [], left: [], ...}}, {2, :c} => %Chess.Square{column: :c, row: 2, loc: {2, :c}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], ...}}, {4, :h} => %Chess.Square{column: :h, row: 4, loc: {4, :h}, piece: nil, sees: %Chess.Square.Sees{up: [], ...}}, {8, :d} => %Chess.Square{column: :d, row: 8, loc: {8, :d}, piece: :Q, sees: %Chess.Square.Sees{...}}, {7, :a} => %Chess.Square{column: :a, row: 7, loc: {7, ...}, piece: :P, ...}, {1, :a} => %Chess.Square{column: :a, row: 1, loc: {...}, ...}, {7, :h} => %Chess.Square{colu (truncated)
22:04:37.743 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
22:04:41.224 [error] ** (Bandit.HTTPError) closed
22:06:29.526 [error] GenServer #PID<0.781.0> terminating
** (MatchError) no match of right hand side value: {:error, :empty_square}
    (chess 0.1.0) lib/chess/board.ex:15: Chess.Board.apply_move/2
    (chess 0.1.0) lib/chess/game.ex:20: Chess.Game.move/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:76: ChessWeb.Chesslive.handle_event/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:508: anonymous fn/3 in Phoenix.LiveView.Channel.view_handle_event/3
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:260: Phoenix.LiveView.Channel.handle_info/2
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:251: :proc_lib.wake_up/3
Last message: %Phoenix.Socket.Message{topic: "lv:phx-GEEGUlUG7dTsaQEF", event: "event", payload: %{"event" => "square-click", "type" => "click", "value" => %{"column" => "e", "row" => "4"}}, ref: "18", join_ref: "4"}
State: %{socket: #Phoenix.LiveView.Socket<id: "phx-GEEGUlUG7dTsaQEF", endpoint: ChessWeb.Endpoint, view: ChessWeb.Chesslive, parent_pid: nil, root_pid: #PID<0.781.0>, router: ChessWeb.Router, assigns: %{__changed__: %{}, flash: %{}, live_action: nil, clicked_square: {1, :e}, game: %Chess.Game{board: %Chess.Board{squares: %{{5, :g} => %Chess.Square{column: :g, row: 5, loc: {5, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :c} => %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :b} => %Chess.Square{column: :b, row: 3, loc: {3, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :c} => %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :a} => %Chess.Square{column: :a, row: 7, loc: {7, :a}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :d} => %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :c} => %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :h} => %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :e} => %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :a} => %Chess.Square{column: :a, row: 5, loc: {5, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :g} => %Chess.Square{column: :g, row: 1, loc: {1, :g}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :d} => %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :e} => %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :h} => %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :e} => %Chess.Square{column: :e, row: 5, loc: {5, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :b} => %Chess.Square{column: :b, row: 4, loc: {4, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :g} => %Chess.Square{column: :g, row: 8, loc: {8, :g}, piece: :N, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :a} => %Chess.Square{column: :a, row: 4, loc: {4, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :d} => %Chess.Square{column: :d, row: 6, loc: {6, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :f} => %Chess.Square{column: :f, row: 6, loc: {6, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :f} => %Chess.Square{column: :f, row: 8, loc: {8, :f}, piece: :B, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], ...}}, {1, :a} => %Chess.Square{column: :a, row: 1, loc: {1, :a}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], ...}}, {2, :a} => %Chess.Square{column: :a, row: 2, loc: {2, :a}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], ...}}, {8, :a} => %Chess.Square{column: :a, row: 8, loc: {8, :a}, piece: :R, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], ...}}, {2, :d} => %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], ...}}, {2, :e} => %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], ...}}, {6, :g} => %Chess.Square{column: :g, row: 6, loc: {6, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], ...}}, {7, :e} => %Chess.Square{column: :e, row: 7, loc: {7, :e}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], ...}}, {2, :f} => %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], ...}}, {7, :c} => %Chess.Square{column: :c, row: 7, loc: {7, :c}, piece: :P, sees: %Chess.Square.Sees{...}}, {7, :f} => %Chess.Square{column: :f, row: 7, loc: {7, ...}, piece: :P, ...}, {8, :h} => %Chess.Square{column: :h, row: 8, loc: {...}, ...}, {4, :g} => %Chess.Square{column: :g, row: 4, ...}, {2, ...} => %Chess.Square{column: :c, ...}, {...} => %Chess.Square{...}, ...}}, turn: :black}}, transport_pid: #PID<0.774.0>, ...>, components: {%{}, %{}, 1}, topic: "lv:phx-GEEGUlUG7dTsaQEF", serializer: Phoenix.Socket.V2.JSONSerializer, join_ref: "4", upload_names: %{}, upload_pids: %{}}
22:07:40.494 [error] GenServer #PID<0.795.0> terminating
** (MatchError) no match of right hand side value: {:error, :empty_square}
    (chess 0.1.0) lib/chess/board.ex:15: Chess.Board.apply_move/2
    (chess 0.1.0) lib/chess/game.ex:20: Chess.Game.move/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:76: ChessWeb.Chesslive.handle_event/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:508: anonymous fn/3 in Phoenix.LiveView.Channel.view_handle_event/3
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:260: Phoenix.LiveView.Channel.handle_info/2
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:251: :proc_lib.wake_up/3
Last message: %Phoenix.Socket.Message{topic: "lv:phx-GEEGUlUG7dTsaQEF", event: "event", payload: %{"event" => "square-click", "type" => "click", "value" => %{"column" => "f", "row" => "4"}}, ref: "23", join_ref: "19"}
State: %{socket: #Phoenix.LiveView.Socket<id: "phx-GEEGUlUG7dTsaQEF", endpoint: ChessWeb.Endpoint, view: ChessWeb.Chesslive, parent_pid: nil, root_pid: #PID<0.795.0>, router: ChessWeb.Router, assigns: %{__changed__: %{}, flash: %{}, live_action: nil, clicked_square: {3, :e}, game: %Chess.Game{board: %Chess.Board{squares: %{{5, :g} => %Chess.Square{column: :g, row: 5, loc: {5, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :c} => %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :b} => %Chess.Square{column: :b, row: 3, loc: {3, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :c} => %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :a} => %Chess.Square{column: :a, row: 7, loc: {7, :a}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :d} => %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :c} => %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :h} => %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :e} => %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :a} => %Chess.Square{column: :a, row: 5, loc: {5, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :g} => %Chess.Square{column: :g, row: 1, loc: {1, :g}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :d} => %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :e} => %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :h} => %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :e} => %Chess.Square{column: :e, row: 5, loc: {5, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :b} => %Chess.Square{column: :b, row: 4, loc: {4, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :g} => %Chess.Square{column: :g, row: 8, loc: {8, :g}, piece: :N, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :a} => %Chess.Square{column: :a, row: 4, loc: {4, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :d} => %Chess.Square{column: :d, row: 6, loc: {6, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :f} => %Chess.Square{column: :f, row: 6, loc: {6, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :f} => %Chess.Square{column: :f, row: 8, loc: {8, :f}, piece: :B, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], ...}}, {1, :a} => %Chess.Square{column: :a, row: 1, loc: {1, :a}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], ...}}, {2, :a} => %Chess.Square{column: :a, row: 2, loc: {2, :a}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], ...}}, {8, :a} => %Chess.Square{column: :a, row: 8, loc: {8, :a}, piece: :R, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], ...}}, {2, :d} => %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], ...}}, {2, :e} => %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], ...}}, {6, :g} => %Chess.Square{column: :g, row: 6, loc: {6, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], ...}}, {7, :e} => %Chess.Square{column: :e, row: 7, loc: {7, :e}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], ...}}, {2, :f} => %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], ...}}, {7, :c} => %Chess.Square{column: :c, row: 7, loc: {7, :c}, piece: :P, sees: %Chess.Square.Sees{...}}, {7, :f} => %Chess.Square{column: :f, row: 7, loc: {7, ...}, piece: :P, ...}, {8, :h} => %Chess.Square{column: :h, row: 8, loc: {...}, ...}, {4, :g} => %Chess.Square{column: :g, row: 4, ...}, {2, ...} => %Chess.Square{column: :c, ...}, {...} => %Chess.Square{...}, ...}}, turn: :white}}, transport_pid: #PID<0.774.0>, ...>, components: {%{}, %{}, 1}, topic: "lv:phx-GEEGUlUG7dTsaQEF", serializer: Phoenix.Socket.V2.JSONSerializer, join_ref: "19", upload_names: %{}, upload_pids: %{}}
22:09:18.445 [error] ** (Bandit.HTTPError) closed
22:09:33.188 [error] GenServer #PID<0.861.0> terminating
** (MatchError) no match of right hand side value: {:error, :empty_square}
    (chess 0.1.0) lib/chess/board.ex:15: Chess.Board.apply_move/2
    (chess 0.1.0) lib/chess/game.ex:20: Chess.Game.move/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:76: ChessWeb.Chesslive.handle_event/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:508: anonymous fn/3 in Phoenix.LiveView.Channel.view_handle_event/3
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:260: Phoenix.LiveView.Channel.handle_info/2
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:241: :proc_lib.init_p_do_apply/3
Last message: %Phoenix.Socket.Message{topic: "lv:phx-GEEGkuJnOSqNYAAm", event: "event", payload: %{"event" => "square-click", "type" => "click", "value" => %{"column" => "e", "row" => "4"}}, ref: "15", join_ref: "4"}
State: %{socket: #Phoenix.LiveView.Socket<id: "phx-GEEGkuJnOSqNYAAm", endpoint: ChessWeb.Endpoint, view: ChessWeb.Chesslive, parent_pid: nil, root_pid: #PID<0.861.0>, router: ChessWeb.Router, assigns: %{__changed__: %{}, flash: %{}, live_action: nil, clicked_square: {1, :e}, game: %Chess.Game{board: %Chess.Board{squares: %{{5, :g} => %Chess.Square{column: :g, row: 5, loc: {5, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :c} => %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :b} => %Chess.Square{column: :b, row: 3, loc: {3, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :c} => %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :a} => %Chess.Square{column: :a, row: 7, loc: {7, :a}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :d} => %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :c} => %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :h} => %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :e} => %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :a} => %Chess.Square{column: :a, row: 5, loc: {5, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :g} => %Chess.Square{column: :g, row: 1, loc: {1, :g}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :d} => %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :e} => %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :h} => %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :e} => %Chess.Square{column: :e, row: 5, loc: {5, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :b} => %Chess.Square{column: :b, row: 4, loc: {4, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :g} => %Chess.Square{column: :g, row: 8, loc: {8, :g}, piece: :N, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :a} => %Chess.Square{column: :a, row: 4, loc: {4, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :d} => %Chess.Square{column: :d, row: 6, loc: {6, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :f} => %Chess.Square{column: :f, row: 6, loc: {6, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :f} => %Chess.Square{column: :f, row: 8, loc: {8, :f}, piece: :B, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], ...}}, {1, :a} => %Chess.Square{column: :a, row: 1, loc: {1, :a}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], ...}}, {2, :a} => %Chess.Square{column: :a, row: 2, loc: {2, :a}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], ...}}, {8, :a} => %Chess.Square{column: :a, row: 8, loc: {8, :a}, piece: :R, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], ...}}, {2, :d} => %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], ...}}, {2, :e} => %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], ...}}, {6, :g} => %Chess.Square{column: :g, row: 6, loc: {6, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], ...}}, {7, :e} => %Chess.Square{column: :e, row: 7, loc: {7, :e}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], ...}}, {2, :f} => %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], ...}}, {7, :c} => %Chess.Square{column: :c, row: 7, loc: {7, :c}, piece: :P, sees: %Chess.Square.Sees{...}}, {7, :f} => %Chess.Square{column: :f, row: 7, loc: {7, ...}, piece: :P, ...}, {8, :h} => %Chess.Square{column: :h, row: 8, loc: {...}, ...}, {4, :g} => %Chess.Square{column: :g, row: 4, ...}, {2, ...} => %Chess.Square{column: :c, ...}, {...} => %Chess.Square{...}, ...}}, turn: :black}}, transport_pid: #PID<0.854.0>, ...>, components: {%{}, %{}, 1}, topic: "lv:phx-GEEGkuJnOSqNYAAm", serializer: Phoenix.Socket.V2.JSONSerializer, join_ref: "4", upload_names: %{}, upload_pids: %{}}
22:09:43.873 [error] GenServer #PID<0.865.0> terminating
** (BadStructError) expected a struct named Chess.Square, got: nil
    (chess 0.1.0) lib/chess/board.ex:23: anonymous fn/1 in Chess.Board.remove_piece_from_square/2
    (elixir 1.15.7) lib/map.ex:957: Map.get_and_update/3
    (chess 0.1.0) lib/chess/board.ex:22: Chess.Board.remove_piece_from_square/2
    (chess 0.1.0) lib/chess/board.ex:15: Chess.Board.apply_move/2
    (chess 0.1.0) lib/chess/game.ex:20: Chess.Game.move/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:76: ChessWeb.Chesslive.handle_event/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:508: anonymous fn/3 in Phoenix.LiveView.Channel.view_handle_event/3
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:260: Phoenix.LiveView.Channel.handle_info/2
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:241: :proc_lib.init_p_do_apply/3
Last message: %Phoenix.Socket.Message{topic: "lv:phx-GEEGkuJnOSqNYAAm", event: "event", payload: %{"event" => "square-click", "type" => "click", "value" => %{"column" => "e", "row" => "4"}}, ref: "18", join_ref: "16"}
State: %{socket: #Phoenix.LiveView.Socket<id: "phx-GEEGkuJnOSqNYAAm", endpoint: ChessWeb.Endpoint, view: ChessWeb.Chesslive, parent_pid: nil, root_pid: #PID<0.865.0>, router: ChessWeb.Router, assigns: %{__changed__: %{}, flash: %{}, live_action: nil, clicked_square: {0, :e}, game: %Chess.Game{board: %Chess.Board{squares: %{{5, :g} => %Chess.Square{column: :g, row: 5, loc: {5, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :c} => %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :b} => %Chess.Square{column: :b, row: 3, loc: {3, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :c} => %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :a} => %Chess.Square{column: :a, row: 7, loc: {7, :a}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :d} => %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :c} => %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :h} => %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :e} => %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :a} => %Chess.Square{column: :a, row: 5, loc: {5, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :g} => %Chess.Square{column: :g, row: 1, loc: {1, :g}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :d} => %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :e} => %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :h} => %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :e} => %Chess.Square{column: :e, row: 5, loc: {5, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :b} => %Chess.Square{column: :b, row: 4, loc: {4, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :g} => %Chess.Square{column: :g, row: 8, loc: {8, :g}, piece: :N, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :a} => %Chess.Square{column: :a, row: 4, loc: {4, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :d} => %Chess.Square{column: :d, row: 6, loc: {6, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :f} => %Chess.Square{column: :f, row: 6, loc: {6, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :f} => %Chess.Square{column: :f, row: 8, loc: {8, :f}, piece: :B, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], ...}}, {1, :a} => %Chess.Square{column: :a, row: 1, loc: {1, :a}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], ...}}, {2, :a} => %Chess.Square{column: :a, row: 2, loc: {2, :a}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], ...}}, {8, :a} => %Chess.Square{column: :a, row: 8, loc: {8, :a}, piece: :R, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], ...}}, {2, :d} => %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], ...}}, {2, :e} => %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], ...}}, {6, :g} => %Chess.Square{column: :g, row: 6, loc: {6, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], ...}}, {7, :e} => %Chess.Square{column: :e, row: 7, loc: {7, :e}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], ...}}, {2, :f} => %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], ...}}, {7, :c} => %Chess.Square{column: :c, row: 7, loc: {7, :c}, piece: :P, sees: %Chess.Square.Sees{...}}, {7, :f} => %Chess.Square{column: :f, row: 7, loc: {7, ...}, piece: :P, ...}, {8, :h} => %Chess.Square{column: :h, row: 8, loc: {...}, ...}, {4, :g} => %Chess.Square{column: :g, row: 4, ...}, {2, ...} => %Chess.Square{column: :c, ...}, {...} => %Chess.Square{...}, ...}}, turn: :white}}, transport_pid: #PID<0.854.0>, ...>, components: {%{}, %{}, 1}, topi (truncated)
22:11:09.068 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
22:12:49.654 [error] ** (Bandit.HTTPError) closed
22:12:58.274 [error] GenServer #PID<0.843.0> terminating
** (MatchError) no match of right hand side value: {:error, :empty_square}
    (chess 0.1.0) lib/chess/board.ex:15: Chess.Board.apply_move/2
    (chess 0.1.0) lib/chess/game.ex:20: Chess.Game.move/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:76: ChessWeb.Chesslive.handle_event/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:508: anonymous fn/3 in Phoenix.LiveView.Channel.view_handle_event/3
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:260: Phoenix.LiveView.Channel.handle_info/2
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:241: :proc_lib.init_p_do_apply/3
Last message: %Phoenix.Socket.Message{topic: "lv:phx-GEEGxA3FQsbwpwAk", event: "event", payload: %{"event" => "square-click", "type" => "click", "value" => %{"column" => "e", "row" => "4"}}, ref: "15", join_ref: "4"}
State: %{socket: #Phoenix.LiveView.Socket<id: "phx-GEEGxA3FQsbwpwAk", endpoint: ChessWeb.Endpoint, view: ChessWeb.Chesslive, parent_pid: nil, root_pid: #PID<0.843.0>, router: ChessWeb.Router, assigns: %{__changed__: %{}, flash: %{}, live_action: nil, clicked_square: {2, :e}, game: %Chess.Game{board: %Chess.Board{squares: %{{5, :g} => %Chess.Square{column: :g, row: 5, loc: {5, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :c} => %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :f} => %Chess.Square{column: :f, row: 7, loc: {7, :f}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :b} => %Chess.Square{column: :b, row: 3, loc: {3, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :c} => %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :a} => %Chess.Square{column: :a, row: 6, loc: {6, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :d} => %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :c} => %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :h} => %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :e} => %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :g} => %Chess.Square{column: :g, row: 1, loc: {1, :g}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :a} => %Chess.Square{column: :a, row: 8, loc: {8, :a}, piece: :R, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :d} => %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :a} => %Chess.Square{column: :a, row: 4, loc: {4, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :a} => %Chess.Square{column: :a, row: 3, loc: {3, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :e} => %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :a} => %Chess.Square{column: :a, row: 1, loc: {1, :a}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :h} => %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :e} => %Chess.Square{column: :e, row: 5, loc: {5, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :b} => %Chess.Square{column: :b, row: 4, loc: {4, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :g} => %Chess.Square{column: :g, row: 8, loc: {8, :g}, piece: :N, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], ...}}, {6, :d} => %Chess.Square{column: :d, row: 6, loc: {6, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], ...}}, {2, :d} => %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], ...}}, {4, :f} => %Chess.Square{column: :f, row: 4, loc: {4, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], ...}}, {2, :e} => %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], ...}}, {6, :g} => %Chess.Square{column: :g, row: 6, loc: {6, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], ...}}, {7, :e} => %Chess.Square{column: :e, row: 7, loc: {7, :e}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], ...}}, {5, :f} => %Chess.Square{column: :f, row: 5, loc: {5, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], ...}}, {3, :f} => %Chess.Square{column: :f, row: 3, loc: {3, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], ...}}, {5, :a} => %Chess.Square{column: :a, row: 5, loc: {5, :a}, piece: nil, sees: %Chess.Square.Sees{...}}, {7, :c} => %Chess.Square{column: :c, row: 7, loc: {7, ...}, piece: :P, ...}, {8, :h} => %Chess.Square{column: :h, row: 8, loc: {...}, ...}, {4, :g} => %Chess.Square{column: :g, row: 4, ...}, {2, ...} => %Chess.Square{column: :c, ...}, {...} => %Chess.Square{...}, ...}}, turn: :black}}, transport_pid: #PID<0.836.0>, ...>, components: {%{}, %{}, 1}, topic: "lv:phx-GEEGxA3FQsbwpwAk", serializer: Phoenix.Socket.V2.JSONSerializer, join_ref: "4", upload_names: %{}, upload_pids: %{}}
18:40:50.340 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
18:42:55.236 [error] GenServer #PID<0.730.0> terminating
** (MatchError) no match of right hand side value: {:error, :empty_square}
    (chess 0.1.0) lib/chess/board.ex:15: Chess.Board.apply_move/2
    (chess 0.1.0) lib/chess/game.ex:20: Chess.Game.move/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:76: ChessWeb.Chesslive.handle_event/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:508: anonymous fn/3 in Phoenix.LiveView.Channel.view_handle_event/3
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:260: Phoenix.LiveView.Channel.handle_info/2
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:251: :proc_lib.wake_up/3
Last message: %Phoenix.Socket.Message{topic: "lv:phx-GEGYYImR_27-mgVB", event: "event", payload: %{"event" => "square-click", "type" => "click", "value" => %{"column" => "f", "row" => "4"}}, ref: "18", join_ref: "4"}
State: %{socket: #Phoenix.LiveView.Socket<id: "phx-GEGYYImR_27-mgVB", endpoint: ChessWeb.Endpoint, view: ChessWeb.Chesslive, parent_pid: nil, root_pid: #PID<0.730.0>, router: ChessWeb.Router, assigns: %{__changed__: %{}, flash: %{}, game: %Chess.Game{board: %Chess.Board{squares: %{{3, :c} => %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :c} => %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :b} => %Chess.Square{column: :b, row: 7, loc: {7, :b}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :b} => %Chess.Square{column: :b, row: 6, loc: {6, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :a} => %Chess.Square{column: :a, row: 4, loc: {4, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :d} => %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :c} => %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :a} => %Chess.Square{column: :a, row: 5, loc: {5, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :h} => %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :a} => %Chess.Square{column: :a, row: 2, loc: {2, :a}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :e} => %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :g} => %Chess.Square{column: :g, row: 4, loc: {4, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :b} => %Chess.Square{column: :b, row: 2, loc: {2, :b}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :f} => %Chess.Square{column: :f, row: 3, loc: {3, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :d} => %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :g} => %Chess.Square{column: :g, row: 5, loc: {5, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :f} => %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :e} => %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :h} => %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :b} => %Chess.Square{column: :b, row: 3, loc: {3, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :e} => %Chess.Square{column: :e, row: 5, loc: {5, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :f} => %Chess.Square{column: :f, row: 4, loc: {4, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :a} => %Chess.Square{column: :a, row: 1, loc: {1, :a}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], ...}}, {6, :d} => %Chess.Square{column: :d, row: 6, loc: {6, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], ...}}, {8, :b} => %Chess.Square{column: :b, row: 8, loc: {8, :b}, piece: :N, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], ...}}, {6, :a} => %Chess.Square{column: :a, row: 6, loc: {6, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], ...}}, {2, :d} => %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], ...}}, {5, :f} => %Chess.Square{column: :f, row: 5, loc: {5, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], ...}}, {2, :e} => %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], ...}}, {4, :b} => %Chess.Square{column: :b, row: 4, loc: {4, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], ...}}, {7, :e} => %Chess.Square{column: :e, row: 7, loc: {7, :e}, piece: :P, sees: %Chess.Square.Sees{up: [], ...}}, {7, :c} => %Chess.Square{column: :c, row: 7, loc: {7, :c}, piece: :P, sees: %Chess.Square.Sees{...}}, {8, :h} => %Chess.Square{column: :h, row: 8, loc: {8, ...}, piece: :R, ...}, {2, :c} => %Chess.Square{column: :c, row: 2, loc: {...}, ...}, {6, :f} => %Chess.Square{column: : (truncated)
18:46:56.287 [error] ** (Bandit.HTTPError) closed
19:06:34.962 [error] ** (Bandit.HTTPError) closed
19:09:01.985 [error] GenServer #PID<0.1068.0> terminating
** (MatchError) no match of right hand side value: {:error, :empty_square}
    (chess 0.1.0) lib/chess/board.ex:17: Chess.Board.apply_move/2
    (chess 0.1.0) lib/chess/game.ex:20: Chess.Game.move/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:77: ChessWeb.Chesslive.handle_event/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:508: anonymous fn/3 in Phoenix.LiveView.Channel.view_handle_event/3
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:260: Phoenix.LiveView.Channel.handle_info/2
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:251: :proc_lib.wake_up/3
Last message: %Phoenix.Socket.Message{topic: "lv:phx-GEGZw09hlMrZIgUD", event: "event", payload: %{"event" => "square-click", "type" => "click", "value" => %{"column" => "a", "row" => "4"}}, ref: "21", join_ref: "4"}
State: %{socket: #Phoenix.LiveView.Socket<id: "phx-GEGZw09hlMrZIgUD", endpoint: ChessWeb.Endpoint, view: ChessWeb.Chesslive, parent_pid: nil, root_pid: #PID<0.1068.0>, router: ChessWeb.Router, assigns: %{__changed__: %{}, flash: %{}, game: %Chess.Game{board: %Chess.Board{squares: %{{3, :c} => %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :c} => %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :b} => %Chess.Square{column: :b, row: 7, loc: {7, :b}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :b} => %Chess.Square{column: :b, row: 6, loc: {6, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :a} => %Chess.Square{column: :a, row: 4, loc: {4, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :d} => %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :c} => %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :a} => %Chess.Square{column: :a, row: 5, loc: {5, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :h} => %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :a} => %Chess.Square{column: :a, row: 2, loc: {2, :a}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :e} => %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :g} => %Chess.Square{column: :g, row: 4, loc: {4, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :b} => %Chess.Square{column: :b, row: 2, loc: {2, :b}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :f} => %Chess.Square{column: :f, row: 3, loc: {3, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :d} => %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :g} => %Chess.Square{column: :g, row: 5, loc: {5, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :f} => %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :e} => %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :h} => %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :b} => %Chess.Square{column: :b, row: 3, loc: {3, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :e} => %Chess.Square{column: :e, row: 5, loc: {5, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :f} => %Chess.Square{column: :f, row: 4, loc: {4, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :a} => %Chess.Square{column: :a, row: 1, loc: {1, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], ...}}, {6, :d} => %Chess.Square{column: :d, row: 6, loc: {6, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], ...}}, {8, :b} => %Chess.Square{column: :b, row: 8, loc: {8, :b}, piece: :N, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], ...}}, {6, :a} => %Chess.Square{column: :a, row: 6, loc: {6, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], ...}}, {2, :d} => %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], ...}}, {5, :f} => %Chess.Square{column: :f, row: 5, loc: {5, :f}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], ...}}, {2, :e} => %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], ...}}, {4, :b} => %Chess.Square{column: :b, row: 4, loc: {4, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], ...}}, {7, :e} => %Chess.Square{column: :e, row: 7, loc: {7, :e}, piece: :P, sees: %Chess.Square.Sees{up: [], ...}}, {7, :c} => %Chess.Square{column: :c, row: 7, loc: {7, :c}, piece: :P, sees: %Chess.Square.Sees{...}}, {8, :h} => %Chess.Square{column: :h, row: 8, loc: {8, ...}, piece: :R, ...}, {2, :c} => %Chess.Square{column: :c, row: 2, loc: {...}, ...}, {6, :f} => %Chess.Square{column:  (truncated)
19:16:50.477 [error] GenServer #PID<0.1165.0> terminating
** (MatchError) no match of right hand side value: {:error, :empty_square}
    (chess 0.1.0) lib/chess/board.ex:17: Chess.Board.apply_move/2
    (chess 0.1.0) lib/chess/game.ex:20: Chess.Game.move/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:78: ChessWeb.Chesslive.handle_event/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:508: anonymous fn/3 in Phoenix.LiveView.Channel.view_handle_event/3
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:260: Phoenix.LiveView.Channel.handle_info/2
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:241: :proc_lib.init_p_do_apply/3
Last message: %Phoenix.Socket.Message{topic: "lv:phx-GEGaUNRoGb7amwXh", event: "event", payload: %{"event" => "square-click", "type" => "click", "value" => %{"column" => "a", "row" => "4"}}, ref: "15", join_ref: "4"}
State: %{socket: #Phoenix.LiveView.Socket<id: "phx-GEGaUNRoGb7amwXh", endpoint: ChessWeb.Endpoint, view: ChessWeb.Chesslive, parent_pid: nil, root_pid: #PID<0.1165.0>, router: ChessWeb.Router, assigns: %{__changed__: %{}, flash: %{}, game: %Chess.Game{board: %Chess.Board{squares: %{{3, :c} => %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :c} => %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :b} => %Chess.Square{column: :b, row: 7, loc: {7, :b}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :b} => %Chess.Square{column: :b, row: 6, loc: {6, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :a} => %Chess.Square{column: :a, row: 4, loc: {4, :a}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :d} => %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :c} => %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :a} => %Chess.Square{column: :a, row: 5, loc: {5, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :h} => %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :a} => %Chess.Square{column: :a, row: 2, loc: {2, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :e} => %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :g} => %Chess.Square{column: :g, row: 4, loc: {4, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :b} => %Chess.Square{column: :b, row: 2, loc: {2, :b}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :f} => %Chess.Square{column: :f, row: 3, loc: {3, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :d} => %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :g} => %Chess.Square{column: :g, row: 5, loc: {5, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :f} => %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :e} => %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :h} => %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :b} => %Chess.Square{column: :b, row: 3, loc: {3, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :e} => %Chess.Square{column: :e, row: 5, loc: {5, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :f} => %Chess.Square{column: :f, row: 4, loc: {4, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :a} => %Chess.Square{column: :a, row: 1, loc: {1, :a}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], ...}}, {6, :d} => %Chess.Square{column: :d, row: 6, loc: {6, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], ...}}, {8, :b} => %Chess.Square{column: :b, row: 8, loc: {8, :b}, piece: :N, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], ...}}, {6, :a} => %Chess.Square{column: :a, row: 6, loc: {6, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], ...}}, {2, :d} => %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], ...}}, {5, :f} => %Chess.Square{column: :f, row: 5, loc: {5, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], ...}}, {2, :e} => %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], ...}}, {4, :b} => %Chess.Square{column: :b, row: 4, loc: {4, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], ...}}, {7, :e} => %Chess.Square{column: :e, row: 7, loc: {7, :e}, piece: :P, sees: %Chess.Square.Sees{up: [], ...}}, {7, :c} => %Chess.Square{column: :c, row: 7, loc: {7, :c}, piece: :P, sees: %Chess.Square.Sees{...}}, {8, :h} => %Chess.Square{column: :h, row: 8, loc: {8, ...}, piece: :R, ...}, {2, :c} => %Chess.Square{column: :c, row: 2, loc: {...}, ...}, {6, :f} => %Chess.Square{ (truncated)
19:38:05.074 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
19:43:18.624 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
19:46:43.926 [error] GenServer #PID<0.769.0> terminating
** (MatchError) no match of right hand side value: {:error, :empty_square}
    (chess 0.1.0) lib/chess/board.ex:17: Chess.Board.apply_move/2
    (chess 0.1.0) lib/chess/game.ex:20: Chess.Game.move/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:80: ChessWeb.Chesslive.handle_event/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:508: anonymous fn/3 in Phoenix.LiveView.Channel.view_handle_event/3
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:260: Phoenix.LiveView.Channel.handle_info/2
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:251: :proc_lib.wake_up/3
Last message: %Phoenix.Socket.Message{topic: "lv:phx-GEGbx_xDCjHeGgdh", event: "event", payload: %{"event" => "square-click", "type" => "click", "value" => %{"column" => "a", "row" => "3"}}, ref: "21", join_ref: "4"}
State: %{socket: #Phoenix.LiveView.Socket<id: "phx-GEGbx_xDCjHeGgdh", endpoint: ChessWeb.Endpoint, view: ChessWeb.Chesslive, parent_pid: nil, root_pid: #PID<0.769.0>, router: ChessWeb.Router, assigns: %{__changed__: %{}, flash: %{}, game: %Chess.Game{board: %Chess.Board{squares: %{{3, :c} => %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :c} => %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :b} => %Chess.Square{column: :b, row: 7, loc: {7, :b}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :b} => %Chess.Square{column: :b, row: 6, loc: {6, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :a} => %Chess.Square{column: :a, row: 3, loc: {3, :a}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :d} => %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :c} => %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :h} => %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :e} => %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :g} => %Chess.Square{column: :g, row: 4, loc: {4, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :b} => %Chess.Square{column: :b, row: 2, loc: {2, :b}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :d} => %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :g} => %Chess.Square{column: :g, row: 5, loc: {5, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :e} => %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :a} => %Chess.Square{column: :a, row: 5, loc: {5, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :f} => %Chess.Square{column: :f, row: 8, loc: {8, :f}, piece: :B, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :h} => %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :b} => %Chess.Square{column: :b, row: 3, loc: {3, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :e} => %Chess.Square{column: :e, row: 5, loc: {5, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :a} => %Chess.Square{column: :a, row: 8, loc: {8, :a}, piece: :R, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :d} => %Chess.Square{column: :d, row: 6, loc: {6, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :b} => %Chess.Square{column: :b, row: 8, loc: {8, :b}, piece: :N, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :d} => %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], ...}}, {2, :e} => %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], ...}}, {4, :b} => %Chess.Square{column: :b, row: 4, loc: {4, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], ...}}, {4, :f} => %Chess.Square{column: :f, row: 4, loc: {4, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], ...}}, {7, :e} => %Chess.Square{column: :e, row: 7, loc: {7, :e}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], ...}}, {3, :f} => %Chess.Square{column: :f, row: 3, loc: {3, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], ...}}, {7, :c} => %Chess.Square{column: :c, row: 7, loc: {7, :c}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], ...}}, {2, :f} => %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], ...}}, {8, :h} => %Chess.Square{column: :h, row: 8, loc: {8, :h}, piece: :R, sees: %Chess.Square.Sees{up: [], ...}}, {2, :c} => %Chess.Square{column: :c, row: 2, loc: {2, :c}, piece: :p, sees: %Chess.Square.Sees{...}}, {6, :a} => %Chess.Square{column: :a, row: 6, loc: {6, ...}, piece: nil, ...}, {1, :a} => %Chess.Square{column: :a, row: 1, loc: {...}, ...}, {4, :h} => %Chess.Square{column: :h,  (truncated)
19:46:54.599 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
19:50:16.374 [error] GenServer #PID<0.731.0> terminating
** (MatchError) no match of right hand side value: {:error, :empty_square}
    (chess 0.1.0) lib/chess/board.ex:17: Chess.Board.apply_move/2
    (chess 0.1.0) lib/chess/game.ex:20: Chess.Game.move/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:81: ChessWeb.Chesslive.handle_event/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:508: anonymous fn/3 in Phoenix.LiveView.Channel.view_handle_event/3
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:260: Phoenix.LiveView.Channel.handle_info/2
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:251: :proc_lib.wake_up/3
Last message: %Phoenix.Socket.Message{topic: "lv:phx-GEGbx_xDCjHeGgdh", event: "event", payload: %{"event" => "square-click", "type" => "click", "value" => %{"column" => "e", "row" => "6"}}, ref: "31", join_ref: "25"}
State: %{socket: #Phoenix.LiveView.Socket<id: "phx-GEGbx_xDCjHeGgdh", endpoint: ChessWeb.Endpoint, view: ChessWeb.Chesslive, parent_pid: nil, root_pid: #PID<0.731.0>, router: ChessWeb.Router, assigns: %{__changed__: %{}, flash: %{}, game: %Chess.Game{board: %Chess.Board{squares: %{{3, :c} => %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :f} => %Chess.Square{column: :f, row: 1, loc: {1, :f}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :c} => %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :g} => %Chess.Square{column: :g, row: 1, loc: {1, :g}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :a} => %Chess.Square{column: :a, row: 1, loc: {1, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :g} => %Chess.Square{column: :g, row: 5, loc: {5, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :d} => %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :c} => %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :h} => %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :e} => %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :f} => %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :a} => %Chess.Square{column: :a, row: 2, loc: {2, :a}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :g} => %Chess.Square{column: :g, row: 8, loc: {8, :g}, piece: :N, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :d} => %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :g} => %Chess.Square{column: :g, row: 3, loc: {3, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :e} => %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :f} => %Chess.Square{column: :f, row: 6, loc: {6, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :h} => %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :e} => %Chess.Square{column: :e, row: 5, loc: {5, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :g} => %Chess.Square{column: :g, row: 7, loc: {7, :g}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :d} => %Chess.Square{column: :d, row: 6, loc: {6, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :d} => %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :b} => %Chess.Square{column: :b, row: 7, loc: {7, :b}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], ...}}, {2, :e} => %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], ...}}, {7, :e} => %Chess.Square{column: :e, row: 7, loc: {7, :e}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], ...}}, {3, :b} => %Chess.Square{column: :b, row: 3, loc: {3, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], ...}}, {7, :c} => %Chess.Square{column: :c, row: 7, loc: {7, :c}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], ...}}, {8, :h} => %Chess.Square{column: :h, row: 8, loc: {8, :h}, piece: :R, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], ...}}, {3, :f} => %Chess.Square{column: :f, row: 3, loc: {3, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], ...}}, {2, :c} => %Chess.Square{column: :c, row: 2, loc: {2, :c}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], ...}}, {4, :h} => %Chess.Square{column: :h, row: 4, loc: {4, :h}, piece: nil, sees: %Chess.Square.Sees{up: [], ...}}, {5, :f} => %Chess.Square{column: :f, row: 5, loc: {5, :f}, piece: nil, sees: %Chess.Square.Sees{...}}, {2, :g} => %Chess.Square{column: :g, row: 2, loc: {2, ...}, piece: :p, ...}, {8, :d} => %Chess.Square{column: :d, row: 8, loc: {...}, ...}, {6, :b} => %Chess.Square{column: :b,  (truncated)
19:53:44.512 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
19:54:08.566 [error] ** (Bandit.HTTPError) closed
19:57:35.206 [error] ** (Bandit.HTTPError) closed
19:57:48.900 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
20:12:56.626 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
19:11:56.939 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
19:12:13.800 [error] ** (Bandit.HTTPError) closed
19:12:48.217 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
19:12:50.300 [error] ** (Bandit.HTTPError) closed
19:14:34.060 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
19:15:06.976 [error] ** (Bandit.HTTPError) closed
19:22:25.646 [error] ** (Bandit.HTTPError) closed
20:38:27.544 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
20:38:35.431 [error] ** (Bandit.HTTPError) closed
16:35:50.439 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
16:35:59.424 [error] ** (Bandit.HTTPError) closed
16:37:30.067 [error] GenServer #PID<0.810.0> terminating
** (FunctionClauseError) no function clause matching in Chess.Pieces.Pawn.moves/2
    (chess 0.1.0) lib/chess/pieces/pawn.ex:38: Chess.Pieces.Pawn.moves(%Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %{{3, :c} => %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :c} => %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :a} => %Chess.Square{column: :a, row: 2, loc: {2, :a}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :f} => %Chess.Square{column: :f, row: 3, loc: {3, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :a} => %Chess.Square{column: :a, row: 6, loc: {6, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :d} => %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :c} => %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :h} => %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :e} => %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :f} => %Chess.Square{column: :f, row: 8, loc: {8, :f}, piece: :B, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :g} => %Chess.Square{column: :g, row: 6, loc: {6, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :d} => %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :e} => %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :h} => %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :b} => %Chess.Square{column: :b, row: 6, loc: {6, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :e} => %Chess.Square{column: :e, row: 5, loc: {5, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :b} => %Chess.Square{column: :b, row: 2, loc: {2, :b}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :d} => %Chess.Square{column: :d, row: 6, loc: {6, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :b} => %Chess.Square{column: :b, row: 5, loc: {5, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :d} => %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :e} => %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :e} => %Chess.Square{column: :e, row: 7, loc: {7, :e}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :f} => %Chess.Square{column: :f, row: 4, loc: {4, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :g} => %Chess.Square{column: :g, row: 7, loc: {7, :g}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :c} => %Chess.Square{column: :c, row: 7, loc: {7, :c}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :g} => %Chess.Square{column: :g, row: 5, loc: {5, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :g} => %Chess.Square{column: :g, row: 8, loc: {8, :g}, piece: :N, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :h} => %Chess.Square{column: :h, row: 8, loc: {8, :h}, piece: :R, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :a} => %Chess.Square{column: :a, row: 1, loc: {1, :a}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :c} => %Chess.Square{column: :c, row: 2, loc: {2, :c}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :a} => %Chess.Square{column: :a, row: 8, loc: {8, :a}, piece: :R, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :h} => %Chess.Square{column: :h, row: 4, loc: {4, :h}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :b} => %Chess.Square{column: :b, row: 1, loc: {1, :b}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :d} => %Chess.Square{column: :d, row: 8, loc: {8, :d}, piece: :Q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_rig (truncated)
16:37:37.291 [error] GenServer #PID<0.813.0> terminating
** (FunctionClauseError) no function clause matching in Chess.Pieces.Pawn.moves/2
    (chess 0.1.0) lib/chess/pieces/pawn.ex:38: Chess.Pieces.Pawn.moves(%Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %{{3, :c} => %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :c} => %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :a} => %Chess.Square{column: :a, row: 2, loc: {2, :a}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :f} => %Chess.Square{column: :f, row: 3, loc: {3, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :a} => %Chess.Square{column: :a, row: 6, loc: {6, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :d} => %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :c} => %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :h} => %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :e} => %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :f} => %Chess.Square{column: :f, row: 8, loc: {8, :f}, piece: :B, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :g} => %Chess.Square{column: :g, row: 6, loc: {6, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :d} => %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :e} => %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :h} => %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :b} => %Chess.Square{column: :b, row: 6, loc: {6, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :e} => %Chess.Square{column: :e, row: 5, loc: {5, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :b} => %Chess.Square{column: :b, row: 2, loc: {2, :b}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :d} => %Chess.Square{column: :d, row: 6, loc: {6, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :b} => %Chess.Square{column: :b, row: 5, loc: {5, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :d} => %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :e} => %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :e} => %Chess.Square{column: :e, row: 7, loc: {7, :e}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :f} => %Chess.Square{column: :f, row: 4, loc: {4, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :g} => %Chess.Square{column: :g, row: 7, loc: {7, :g}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :c} => %Chess.Square{column: :c, row: 7, loc: {7, :c}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :g} => %Chess.Square{column: :g, row: 5, loc: {5, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :g} => %Chess.Square{column: :g, row: 8, loc: {8, :g}, piece: :N, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :h} => %Chess.Square{column: :h, row: 8, loc: {8, :h}, piece: :R, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :a} => %Chess.Square{column: :a, row: 1, loc: {1, :a}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :c} => %Chess.Square{column: :c, row: 2, loc: {2, :c}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :a} => %Chess.Square{column: :a, row: 8, loc: {8, :a}, piece: :R, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :h} => %Chess.Square{column: :h, row: 4, loc: {4, :h}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :b} => %Chess.Square{column: :b, row: 1, loc: {1, :b}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :d} => %Chess.Square{column: :d, row: 8, loc: {8, :d}, piece: :Q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_rig (truncated)
16:42:26.448 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
16:44:07.729 [error] ** (Bandit.HTTPError) closed
16:44:51.549 [error] ** (Bandit.HTTPError) closed
16:22:51.458 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
20:29:22.281 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
20:29:29.001 [error] ** (Bandit.HTTPError) closed
21:45:59.101 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
21:46:34.197 [error] ** (Bandit.HTTPError) closed
21:49:01.331 [error] ** (Bandit.HTTPError) closed
19:11:33.445 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
19:13:37.796 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
19:13:55.904 [error] ** (Bandit.HTTPError) closed
20:58:39.701 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
21:17:27.338 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
21:17:35.940 [error] ** (Bandit.HTTPError) closed
21:30:32.649 [error] ** (Bandit.HTTPError) closed
21:30:37.307 [error] GenServer #PID<0.1007.0> terminating
** (ArgumentError) errors were found at the given arguments:

  * 1st argument: the device does not exist

    (stdlib 5.2.3.1) io.erl:98: :io.put_chars(:p, [[label: "targeted piece"], 10])
    (chess 0.1.0) lib/chess/move_builder.ex:19: anonymous fn/6 in Chess.MoveBuilder.build_moves/4
    (elixir 1.15.7) lib/enum.ex:4830: Enumerable.List.reduce/3
    (elixir 1.15.7) lib/enum.ex:2564: Enum.reduce_while/3
    (elixir 1.15.7) lib/enum.ex:4317: Enum.flat_map_list/2
    (chess 0.1.0) lib/chess/game.ex:50: Chess.Game.validate_move/3
    (chess 0.1.0) lib/chess/game.ex:23: Chess.Game.move/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:81: ChessWeb.Chesslive.handle_event/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:508: anonymous fn/3 in Phoenix.LiveView.Channel.view_handle_event/3
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:260: Phoenix.LiveView.Channel.handle_info/2
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:241: :proc_lib.init_p_do_apply/3
Last message: %Phoenix.Socket.Message{topic: "lv:phx-GEhiYvgAfGZukgCC", event: "event", payload: %{"event" => "square-click", "type" => "click", "value" => %{"column" => "f", "row" => "4"}}, ref: "19", join_ref: "4"}
State: %{socket: #Phoenix.LiveView.Socket<id: "phx-GEhiYvgAfGZukgCC", endpoint: ChessWeb.Endpoint, view: ChessWeb.Chesslive, parent_pid: nil, root_pid: #PID<0.1007.0>, router: ChessWeb.Router, assigns: %{__changed__: %{}, flash: %{}, game: %Chess.Game{board: %Chess.Board{squares: %{{3, :c} => %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :c} => %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :a} => %Chess.Square{column: :a, row: 2, loc: {2, :a}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :d} => %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :c} => %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :h} => %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :a} => %Chess.Square{column: :a, row: 8, loc: {8, :a}, piece: :R, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :e} => %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :a} => %Chess.Square{column: :a, row: 1, loc: {1, :a}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :f} => %Chess.Square{column: :f, row: 5, loc: {5, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :b} => %Chess.Square{column: :b, row: 1, loc: {1, :b}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :d} => %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :g} => %Chess.Square{column: :g, row: 1, loc: {1, :g}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :e} => %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :h} => %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :e} => %Chess.Square{column: :e, row: 5, loc: {5, :e}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :a} => %Chess.Square{column: :a, row: 7, loc: {7, :a}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :d} => %Chess.Square{column: :d, row: 6, loc: {6, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :f} => %Chess.Square{column: :f, row: 7, loc: {7, :f}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :d} => %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :a} => %Chess.Square{column: :a, row: 4, loc: {4, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :e} => %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :e} => %Chess.Square{column: :e, row: 7, loc: {7, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], ...}}, {4, :f} => %Chess.Square{column: :f, row: 4, loc: {4, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], ...}}, {4, :g} => %Chess.Square{column: :g, row: 4, loc: {4, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], ...}}, {7, :c} => %Chess.Square{column: :c, row: 7, loc: {7, :c}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], ...}}, {3, :g} => %Chess.Square{column: :g, row: 3, loc: {3, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], ...}}, {8, :h} => %Chess.Square{column: :h, row: 8, loc: {8, :h}, piece: :R, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], ...}}, {2, :c} => %Chess.Square{column: :c, row: 2, loc: {2, :c}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], ...}}, {8, :f} => %Chess.Square{column: :f, row: 8, loc: {8, :f}, piece: :B, sees: %Chess.Square.Sees{up: [], down:  (truncated)
21:44:18.491 [error] ** (Bandit.HTTPError) closed
22:15:18.798 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
22:15:31.944 [error] GenServer #PID<0.721.0> terminating
** (FunctionClauseError) no function clause matching in Chess.Pieces.PiecesLib.generate_paths/3
    (chess 0.1.0) lib/chess/pieces/pieces_lib.ex:17: Chess.Pieces.PiecesLib.generate_paths(%Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, 0}, 8)
    (elixir 1.15.7) lib/enum.ex:4317: Enum.flat_map_list/2
    (chess 0.1.0) lib/chess/pieces/queen.ex:17: Chess.Pieces.Queen.moves/2
    (elixir 1.15.7) lib/enum.ex:4317: Enum.flat_map_list/2
    (chess 0.1.0) lib/chess/game.ex:50: Chess.Game.validate_move/3
    (chess 0.1.0) lib/chess/game.ex:23: Chess.Game.move/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:81: ChessWeb.Chesslive.handle_event/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:508: anonymous fn/3 in Phoenix.LiveView.Channel.view_handle_event/3
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:260: Phoenix.LiveView.Channel.handle_info/2
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:241: :proc_lib.init_p_do_apply/3
Last message: %Phoenix.Socket.Message{topic: "lv:phx-GEhk1fdyRTJSeQUB", event: "event", payload: %{"event" => "square-click", "type" => "click", "value" => %{"column" => "g", "row" => "4"}}, ref: "16", join_ref: "10"}
State: %{socket: #Phoenix.LiveView.Socket<id: "phx-GEhk1fdyRTJSeQUB", endpoint: ChessWeb.Endpoint, view: ChessWeb.Chesslive, parent_pid: nil, root_pid: #PID<0.721.0>, router: ChessWeb.Router, assigns: %{__changed__: %{}, flash: %{}, clicked_square: {1, :d}, game: %Chess.Game{board: %Chess.Board{squares: %{{3, :c} => %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :f} => %Chess.Square{column: :f, row: 8, loc: {8, :f}, piece: :B, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :c} => %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :b} => %Chess.Square{column: :b, row: 6, loc: {6, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :f} => %Chess.Square{column: :f, row: 4, loc: {4, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :d} => %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :c} => %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :b} => %Chess.Square{column: :b, row: 8, loc: {8, :b}, piece: :N, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :h} => %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :a} => %Chess.Square{column: :a, row: 7, loc: {7, :a}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :e} => %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :b} => %Chess.Square{column: :b, row: 7, loc: {7, :b}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :b} => %Chess.Square{column: :b, row: 4, loc: {4, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :d} => %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :f} => %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :e} => %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :h} => %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :e} => %Chess.Square{column: :e, row: 5, loc: {5, :e}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :d} => %Chess.Square{column: :d, row: 6, loc: {6, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :a} => %Chess.Square{column: :a, row: 5, loc: {5, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :g} => %Chess.Square{column: :g, row: 2, loc: {2, :g}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :d} => %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], ...}}, {1, :a} => %Chess.Square{column: :a, row: 1, loc: {1, :a}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], ...}}, {2, :e} => %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], ...}}, {7, :e} => %Chess.Square{column: :e, row: 7, loc: {7, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], ...}}, {1, :b} => %Chess.Square{column: :b, row: 1, loc: {1, :b}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], ...}}, {7, :c} => %Chess.Square{column: :c, row: 7, loc: {7, :c}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], ...}}, {8, :h} => %Chess.Square{column: :h, row: 8, loc: {8, :h}, piece: :R, sees: %Chess.Square.Sees{up: [], down: [], left: [], ...}}, {5, :g} => %Chess.Square{column: :g, row: 5, loc: {5, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], ...}}, {2, :c} => %Chess.Square{column: :c, row: 2, loc: {2 (truncated)
22:17:01.356 [error] GenServer #PID<0.970.0> terminating
** (FunctionClauseError) no function clause matching in Chess.Pieces.PiecesLib.generate_paths/3
    (chess 0.1.0) lib/chess/pieces/pieces_lib.ex:17: Chess.Pieces.PiecesLib.generate_paths(%Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, 0}, 8)
    (elixir 1.15.7) lib/enum.ex:4317: Enum.flat_map_list/2
    (chess 0.1.0) lib/chess/pieces/queen.ex:18: Chess.Pieces.Queen.moves/2
    (elixir 1.15.7) lib/enum.ex:4317: Enum.flat_map_list/2
    (chess 0.1.0) lib/chess/game.ex:50: Chess.Game.validate_move/3
    (chess 0.1.0) lib/chess/game.ex:23: Chess.Game.move/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:81: ChessWeb.Chesslive.handle_event/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:508: anonymous fn/3 in Phoenix.LiveView.Channel.view_handle_event/3
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:260: Phoenix.LiveView.Channel.handle_info/2
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:241: :proc_lib.init_p_do_apply/3
Last message: %Phoenix.Socket.Message{topic: "lv:phx-GEhk6rtM5YDSVwAi", event: "event", payload: %{"event" => "square-click", "type" => "click", "value" => %{"column" => "g", "row" => "4"}}, ref: "13", join_ref: "4"}
State: %{socket: #Phoenix.LiveView.Socket<id: "phx-GEhk6rtM5YDSVwAi", endpoint: ChessWeb.Endpoint, view: ChessWeb.Chesslive, parent_pid: nil, root_pid: #PID<0.970.0>, router: ChessWeb.Router, assigns: %{__changed__: %{}, flash: %{}, clicked_square: {1, :d}, game: %Chess.Game{board: %Chess.Board{squares: %{{3, :c} => %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :f} => %Chess.Square{column: :f, row: 8, loc: {8, :f}, piece: :B, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :c} => %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :b} => %Chess.Square{column: :b, row: 6, loc: {6, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :f} => %Chess.Square{column: :f, row: 4, loc: {4, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :d} => %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :c} => %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :b} => %Chess.Square{column: :b, row: 8, loc: {8, :b}, piece: :N, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :h} => %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :a} => %Chess.Square{column: :a, row: 7, loc: {7, :a}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :e} => %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :b} => %Chess.Square{column: :b, row: 7, loc: {7, :b}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :b} => %Chess.Square{column: :b, row: 4, loc: {4, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :d} => %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :f} => %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :e} => %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :h} => %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :e} => %Chess.Square{column: :e, row: 5, loc: {5, :e}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :d} => %Chess.Square{column: :d, row: 6, loc: {6, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :a} => %Chess.Square{column: :a, row: 5, loc: {5, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :g} => %Chess.Square{column: :g, row: 2, loc: {2, :g}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :d} => %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], ...}}, {1, :a} => %Chess.Square{column: :a, row: 1, loc: {1, :a}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], ...}}, {2, :e} => %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], ...}}, {7, :e} => %Chess.Square{column: :e, row: 7, loc: {7, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], ...}}, {1, :b} => %Chess.Square{column: :b, row: 1, loc: {1, :b}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], ...}}, {7, :c} => %Chess.Square{column: :c, row: 7, loc: {7, :c}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], ...}}, {8, :h} => %Chess.Square{column: :h, row: 8, loc: {8, :h}, piece: :R, sees: %Chess.Square.Sees{up: [], down: [], left: [], ...}}, {5, :g} => %Chess.Square{column: :g, row: 5, loc: {5, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], ...}}, {2, :c} => %Chess.Square{column: :c, row: 2, loc: {2, (truncated)
22:21:16.827 [error] ** (Bandit.HTTPError) closed
23:09:26.713 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
23:09:33.720 [error] ** (Bandit.HTTPError) closed
23:09:35.410 [error] GenServer #PID<0.799.0> terminating
** (Protocol.UndefinedError) protocol Enumerable not implemented for {3, 4} of type Tuple. This protocol is implemented for the following type(s): DBConnection.PrepareStream, DBConnection.Stream, Date.Range, Ecto.Adapters.SQL.Stream, File.Stream, Function, GenEvent.Stream, HashDict, HashSet, IO.Stream, Jason.OrderedObject, List, Map, MapSet, Phoenix.LiveView.LiveStream, Postgrex.Stream, Range, Stream
    (elixir 1.15.7) lib/enum.ex:1: Enumerable.impl_for!/1
    (elixir 1.15.7) lib/enum.ex:166: Enumerable.reduce/3
    (elixir 1.15.7) lib/enum.ex:2564: Enum.reduce_while/3
    (elixir 1.15.7) lib/enum.ex:2510: Enum."-reduce/3-lists^foldl/2-0-"/3
    (chess 0.1.0) lib/chess/pieces/pawn.ex:14: Chess.Pieces.Pawn.moves/2
    (elixir 1.15.7) lib/enum.ex:4317: Enum.flat_map_list/2
    (chess 0.1.0) lib/chess/game.ex:50: Chess.Game.validate_move/3
    (chess 0.1.0) lib/chess/game.ex:23: Chess.Game.move/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:81: ChessWeb.Chesslive.handle_event/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:508: anonymous fn/3 in Phoenix.LiveView.Channel.view_handle_event/3
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:260: Phoenix.LiveView.Channel.handle_info/2
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:241: :proc_lib.init_p_do_apply/3
Last message: %Phoenix.Socket.Message{topic: "lv:phx-GEhnyj1c03le6gVB", event: "event", payload: %{"event" => "square-click", "type" => "click", "value" => %{"column" => "e", "row" => "4"}}, ref: "9", join_ref: "4"}
State: %{socket: #Phoenix.LiveView.Socket<id: "phx-GEhnyj1c03le6gVB", endpoint: ChessWeb.Endpoint, view: ChessWeb.Chesslive, parent_pid: nil, root_pid: #PID<0.799.0>, router: ChessWeb.Router, assigns: %{__changed__: %{}, flash: %{}, live_action: nil, clicked_square: {2, :e}, game: %Chess.Game{board: %Chess.Board{squares: %{{3, :c} => %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :a} => %Chess.Square{column: :a, row: 3, loc: {3, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :c} => %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :b} => %Chess.Square{column: :b, row: 6, loc: {6, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :d} => %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :c} => %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :a} => %Chess.Square{column: :a, row: 7, loc: {7, :a}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :b} => %Chess.Square{column: :b, row: 8, loc: {8, :b}, piece: :N, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :h} => %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :e} => %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :b} => %Chess.Square{column: :b, row: 7, loc: {7, :b}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :f} => %Chess.Square{column: :f, row: 5, loc: {5, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :f} => %Chess.Square{column: :f, row: 3, loc: {3, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :g} => %Chess.Square{column: :g, row: 3, loc: {3, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :b} => %Chess.Square{column: :b, row: 4, loc: {4, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :d} => %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :g} => %Chess.Square{column: :g, row: 6, loc: {6, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :f} => %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :e} => %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :h} => %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :e} => %Chess.Square{column: :e, row: 5, loc: {5, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], ...}}, {6, :d} => %Chess.Square{column: :d, row: 6, loc: {6, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], ...}}, {2, :d} => %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], ...}}, {2, :e} => %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], ...}}, {7, :e} => %Chess.Square{column: :e, row: 7, loc: {7, :e}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], ...}}, {1, :b} => %Chess.Square{column: :b, row: 1, loc: {1, :b}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], ...}}, {7, :c} => %Chess.Square{column: :c, row: 7, loc: {7, :c}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], ...}}, {4, :a} => %Chess.Square{column: :a, row: 4, loc: {4, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], ...}}, {8, :h} => %Chess.Square{column: :h, row: 8, loc: {8, :h}, piece: :R, sees: %Chess.Sq (truncated)
23:16:16.525 [error] ** (Bandit.HTTPError) closed
23:16:18.003 [error] GenServer #PID<0.1189.0> terminating
** (Protocol.UndefinedError) protocol Enumerable not implemented for {1, 0} of type Tuple
    (elixir 1.15.7) lib/enum.ex:1: Enumerable.impl_for!/1
    (elixir 1.15.7) lib/enum.ex:166: Enumerable.reduce/3
    (elixir 1.15.7) lib/enum.ex:4387: Enum.map/2
    (chess 0.1.0) lib/chess/pieces/pawn.ex:13: Chess.Pieces.Pawn.moves/2
    (elixir 1.15.7) lib/enum.ex:4317: Enum.flat_map_list/2
    (chess 0.1.0) lib/chess/game.ex:50: Chess.Game.validate_move/3
    (chess 0.1.0) lib/chess/game.ex:23: Chess.Game.move/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:81: ChessWeb.Chesslive.handle_event/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:508: anonymous fn/3 in Phoenix.LiveView.Channel.view_handle_event/3
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:260: Phoenix.LiveView.Channel.handle_info/2
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:241: :proc_lib.init_p_do_apply/3
Last message: %Phoenix.Socket.Message{topic: "lv:phx-GEhoKAj9deH24wDi", event: "event", payload: %{"event" => "square-click", "type" => "click", "value" => %{"column" => "e", "row" => "4"}}, ref: "9", join_ref: "4"}
State: %{socket: #Phoenix.LiveView.Socket<id: "phx-GEhoKAj9deH24wDi", endpoint: ChessWeb.Endpoint, view: ChessWeb.Chesslive, parent_pid: nil, root_pid: #PID<0.1189.0>, router: ChessWeb.Router, assigns: %{__changed__: %{}, flash: %{}, live_action: nil, clicked_square: {2, :e}, game: %Chess.Game{board: %Chess.Board{squares: %{{3, :c} => %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :a} => %Chess.Square{column: :a, row: 3, loc: {3, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :c} => %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :b} => %Chess.Square{column: :b, row: 6, loc: {6, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :d} => %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :c} => %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :a} => %Chess.Square{column: :a, row: 7, loc: {7, :a}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :b} => %Chess.Square{column: :b, row: 8, loc: {8, :b}, piece: :N, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :h} => %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :e} => %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :b} => %Chess.Square{column: :b, row: 7, loc: {7, :b}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :f} => %Chess.Square{column: :f, row: 5, loc: {5, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :f} => %Chess.Square{column: :f, row: 3, loc: {3, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :g} => %Chess.Square{column: :g, row: 3, loc: {3, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :b} => %Chess.Square{column: :b, row: 4, loc: {4, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :d} => %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :g} => %Chess.Square{column: :g, row: 6, loc: {6, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :f} => %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :e} => %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :h} => %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :e} => %Chess.Square{column: :e, row: 5, loc: {5, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], ...}}, {6, :d} => %Chess.Square{column: :d, row: 6, loc: {6, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], ...}}, {2, :d} => %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], ...}}, {2, :e} => %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], ...}}, {7, :e} => %Chess.Square{column: :e, row: 7, loc: {7, :e}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], ...}}, {1, :b} => %Chess.Square{column: :b, row: 1, loc: {1, :b}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], ...}}, {7, :c} => %Chess.Square{column: :c, row: 7, loc: {7, :c}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], ...}}, {4, :a} => %Chess.Square{column: :a, row: 4, loc: {4, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], ...}}, {8, :h} => %Chess.Square{column: :h, row: 8, loc: {8, :h}, piece: :R, sees: %Chess.Square.Sees{up: [], ...}}, {2, :c} => %Chess.Square{column: :c, row: 2, loc: {2, :c}, piece: :p, sees: %Chess.Square.Sees{...}}, {2, :a} => %Chess.Square{column: :a, row: 2, loc: {2, ...}, piece: :p, ...}, {4, :h} => %Chess.Square{column: :h, row: 4, loc: {...}, ...}, {8, :d} => %Chess.Square{column: :d, row: 8, ...}, {6, ...} => %Chess.Square{column: :a, ...}, {...} => %Chess.Square{...}, ...} (truncated)
23:17:17.925 [error] ** (Bandit.HTTPError) closed
23:17:36.826 [error] GenServer #PID<0.1368.0> terminating
** (UndefinedFunctionError) function Chess.MoveBuilder.build_moves/4 is undefined or private
    (chess 0.1.0) Chess.MoveBuilder.build_moves([[{2, 3}, {3, 3}, {4, 3}, {5, 3}, {6, 3}, {7, 3}, {8, 3}], [], [{1, 4}, {1, 5}, {1, 6}, {1, 7}], [{1, 2}, {1, 1}, {1, 0}], [{2, 4}, {3, 5}, {4, 6}, {5, 7}], [{2, 2}, {3, 1}, {4, 0}], [], []], %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %{{3, :c} => %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :a} => %Chess.Square{column: :a, row: 3, loc: {3, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :c} => %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :b} => %Chess.Square{column: :b, row: 6, loc: {6, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :d} => %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :c} => %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :a} => %Chess.Square{column: :a, row: 7, loc: {7, :a}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :b} => %Chess.Square{column: :b, row: 8, loc: {8, :b}, piece: :N, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :h} => %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :e} => %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :b} => %Chess.Square{column: :b, row: 7, loc: {7, :b}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :f} => %Chess.Square{column: :f, row: 5, loc: {5, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :f} => %Chess.Square{column: :f, row: 3, loc: {3, :f}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :g} => %Chess.Square{column: :g, row: 3, loc: {3, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :b} => %Chess.Square{column: :b, row: 4, loc: {4, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :d} => %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :g} => %Chess.Square{column: :g, row: 6, loc: {6, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :f} => %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :e} => %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :h} => %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :e} => %Chess.Square{column: :e, row: 5, loc: {5, :e}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :d} => %Chess.Square{column: :d, row: 6, loc: {6, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :d} => %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :e} => %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :e} => %Chess.Square{column: :e, row: 7, loc: {7, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :b} => %Chess.Square{column: :b, row: 1, loc: {1, :b}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :c} => %Chess.Square{column: :c, row: 7, loc: {7, :c}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :a} => %Chess.Square{column: :a, row: 4, loc: {4, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :h} => %Chess.Square{column: :h, row: 8, loc: {8, :h}, piece: :R, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :c} => %Chess.Square{column: :c, row: 2, loc: {2, :c}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :a} => %Chess.Square{column: :a, row: 2, loc: {2, :a}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :h} => %Chess.Square{column: :h, row: 4, loc: {4, :h}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :d} => %Chess.Square{column: :d, row: 8, loc: {8, :d}, piece: :Q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, { (truncated)
23:19:13.651 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
23:19:40.803 [error] GenServer #PID<0.718.0> terminating
** (UndefinedFunctionError) function MoveBuilder.build_moves/3 is undefined (module MoveBuilder is not available)
    MoveBuilder.build_moves([[], [{7, 7}, {6, 7}, {5, 7}, {4, 7}, {3, 7}, {2, 7}, {1, 7}], [{8, 6}, {8, 5}, {8, 4}, {8, 3}, {8, 2}, {8, 1}, {8, 0}], []], %Chess.Square{column: :h, row: 8, loc: {8, :h}, piece: :R, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, %{{3, :c} => %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :g} => %Chess.Square{column: :g, row: 1, loc: {1, :g}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :c} => %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :d} => %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :c} => %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :h} => %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :a} => %Chess.Square{column: :a, row: 6, loc: {6, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :e} => %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :f} => %Chess.Square{column: :f, row: 7, loc: {7, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :d} => %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :a} => %Chess.Square{column: :a, row: 4, loc: {4, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :e} => %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :b} => %Chess.Square{column: :b, row: 6, loc: {6, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :h} => %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :b} => %Chess.Square{column: :b, row: 5, loc: {5, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :e} => %Chess.Square{column: :e, row: 5, loc: {5, :e}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :d} => %Chess.Square{column: :d, row: 6, loc: {6, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :f} => %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :d} => %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :e} => %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :e} => %Chess.Square{column: :e, row: 7, loc: {7, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :g} => %Chess.Square{column: :g, row: 2, loc: {2, :g}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :g} => %Chess.Square{column: :g, row: 4, loc: {4, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :c} => %Chess.Square{column: :c, row: 7, loc: {7, :c}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :h} => %Chess.Square{column: :h, row: 8, loc: {8, :h}, piece: :R, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :b} => %Chess.Square{column: :b, row: 4, loc: {4, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :f} => %Chess.Square{column: :f, row: 6, loc: {6, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :c} => %Chess.Square{column: :c, row: 2, loc: {2, :c}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :g} => %Chess.Square{column: :g, row: 5, loc: {5, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :h} => %Chess.Square{column: :h, row: 4, loc: {4, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :b} => %Chess.Square{column: :b, row: 8, loc: {8, :b}, piece: :N, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :d} => %Chess.Square{column: :d, row: 8, loc: {8, :d}, piece: :Q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :g} => %Chess.Square{column: :g, row: 3, loc: {3, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :h} => %Chess.Square{column: :h, row: 7, loc: {7, :h}, piece (truncated)
23:21:18.780 [error] ** (Bandit.HTTPError) closed
23:21:53.327 [error] GenServer #PID<0.1331.0> terminating
** (FunctionClauseError) no function clause matching in Chess.Pieces.PiecesLib.generate_paths/3
    (chess 0.1.0) lib/chess/pieces/pieces_lib.ex:17: Chess.Pieces.PiecesLib.generate_paths(%Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, 1}, 8)
    (elixir 1.15.7) lib/enum.ex:1693: Enum."-map/2-lists^map/1-1-"/2
    (chess 0.1.0) lib/chess/pieces/bishop.ex:18: Chess.Pieces.Bishop.moves/2
    (elixir 1.15.7) lib/enum.ex:4317: Enum.flat_map_list/2
    (chess 0.1.0) lib/chess/game.ex:50: Chess.Game.validate_move/3
    (chess 0.1.0) lib/chess/game.ex:23: Chess.Game.move/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:81: ChessWeb.Chesslive.handle_event/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:508: anonymous fn/3 in Phoenix.LiveView.Channel.view_handle_event/3
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:260: Phoenix.LiveView.Channel.handle_info/2
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:241: :proc_lib.init_p_do_apply/3
Last message: %Phoenix.Socket.Message{topic: "lv:phx-GEhobmk3qu8CCQUB", event: "event", payload: %{"event" => "square-click", "type" => "click", "value" => %{"column" => "b", "row" => "2"}}, ref: "41", join_ref: "4"}
State: %{socket: #Phoenix.LiveView.Socket<id: "phx-GEhobmk3qu8CCQUB", endpoint: ChessWeb.Endpoint, view: ChessWeb.Chesslive, parent_pid: nil, root_pid: #PID<0.1331.0>, router: ChessWeb.Router, assigns: %{__changed__: %{}, flash: %{}, live_action: nil, clicked_square: {1, :c}, game: %Chess.Game{board: %Chess.Board{squares: %{{3, :c} => %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :g} => %Chess.Square{column: :g, row: 1, loc: {1, :g}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :c} => %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :d} => %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :c} => %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :h} => %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :a} => %Chess.Square{column: :a, row: 6, loc: {6, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :e} => %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :f} => %Chess.Square{column: :f, row: 7, loc: {7, :f}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :d} => %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :a} => %Chess.Square{column: :a, row: 4, loc: {4, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :e} => %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :b} => %Chess.Square{column: :b, row: 6, loc: {6, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :h} => %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :b} => %Chess.Square{column: :b, row: 5, loc: {5, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :e} => %Chess.Square{column: :e, row: 5, loc: {5, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :d} => %Chess.Square{column: :d, row: 6, loc: {6, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :f} => %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :d} => %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :e} => %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :e} => %Chess.Square{column: :e, row: 7, loc: {7, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], ...}}, {2, :g} => %Chess.Square{column: :g, row: 2, loc: {2, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], ...}}, {4, :g} => %Chess.Square{column: :g, row: 4, loc: {4, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], ...}}, {7, :c} => %Chess.Square{column: :c, row: 7, loc: {7, :c}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], ...}}, {8, :h} => %Chess.Square{column: :h, row: 8, loc: {8, :h}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], ...}}, {4, :b} => %Chess.Square{column: :b, row: 4, loc: {4, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], ...}}, {6, :f} => %Chess.Square{column: :f, row: 6, loc: {6, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], ...}}, {2, :c} => %Chess.Square{column: :c, row: 2, loc: {2, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], ...}}, {5, :g} => %Chess.Square{column: :g, row: 5, loc: {5, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], ...}}, {4, :h} => %Chess.Square{column: :h, row: 4, loc: {4, :h}, piece: nil, sees: %Chess.Square.Sees{...}}, {8, :b} => %Chess.Square{ (truncated)
23:23:59.957 [error] GenServer #PID<0.1763.0> terminating
** (FunctionClauseError) no function clause matching in Chess.Pieces.PiecesLib.generate_paths/3
    (chess 0.1.0) lib/chess/pieces/pieces_lib.ex:17: Chess.Pieces.PiecesLib.generate_paths(%Chess.Square{column: :g, row: 1, loc: {1, :g}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, 1}, 1)
    (elixir 1.15.7) lib/enum.ex:1693: Enum."-map/2-lists^map/1-1-"/2
    (chess 0.1.0) lib/chess/pieces/knight.ex:17: Chess.Pieces.Knight.moves/2
    (elixir 1.15.7) lib/enum.ex:4317: Enum.flat_map_list/2
    (chess 0.1.0) lib/chess/game.ex:50: Chess.Game.validate_move/3
    (chess 0.1.0) lib/chess/game.ex:23: Chess.Game.move/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:81: ChessWeb.Chesslive.handle_event/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:508: anonymous fn/3 in Phoenix.LiveView.Channel.view_handle_event/3
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:260: Phoenix.LiveView.Channel.handle_info/2
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:251: :proc_lib.wake_up/3
Last message: %Phoenix.Socket.Message{topic: "lv:phx-GEhobmk3qu8CCQUB", event: "event", payload: %{"event" => "square-click", "type" => "click", "value" => %{"column" => "f", "row" => "3"}}, ref: "86", join_ref: "42"}
State: %{socket: #Phoenix.LiveView.Socket<id: "phx-GEhobmk3qu8CCQUB", endpoint: ChessWeb.Endpoint, view: ChessWeb.Chesslive, parent_pid: nil, root_pid: #PID<0.1763.0>, router: ChessWeb.Router, assigns: %{__changed__: %{}, flash: %{}, live_action: nil, clicked_square: {1, :g}, game: %Chess.Game{board: %Chess.Board{squares: %{{3, :c} => %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :g} => %Chess.Square{column: :g, row: 1, loc: {1, :g}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :c} => %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :d} => %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :c} => %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :h} => %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :a} => %Chess.Square{column: :a, row: 6, loc: {6, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :e} => %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :f} => %Chess.Square{column: :f, row: 7, loc: {7, :f}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :d} => %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :a} => %Chess.Square{column: :a, row: 4, loc: {4, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :e} => %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :b} => %Chess.Square{column: :b, row: 6, loc: {6, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :h} => %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :b} => %Chess.Square{column: :b, row: 5, loc: {5, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :e} => %Chess.Square{column: :e, row: 5, loc: {5, :e}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :d} => %Chess.Square{column: :d, row: 6, loc: {6, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :f} => %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :d} => %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :e} => %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :e} => %Chess.Square{column: :e, row: 7, loc: {7, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], ...}}, {2, :g} => %Chess.Square{column: :g, row: 2, loc: {2, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], ...}}, {4, :g} => %Chess.Square{column: :g, row: 4, loc: {4, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], ...}}, {7, :c} => %Chess.Square{column: :c, row: 7, loc: {7, :c}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], ...}}, {8, :h} => %Chess.Square{column: :h, row: 8, loc: {8, :h}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], ...}}, {4, :b} => %Chess.Square{column: :b, row: 4, loc: {4, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], ...}}, {6, :f} => %Chess.Square{column: :f, row: 6, loc: {6, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], ...}}, {2, :c} => %Chess.Square{column: :c, row: 2, loc: {2, :c}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], ...}}, {5, :g} => %Chess.Square{column: :g, row: 5, loc: {5, :g}, piece: :p, sees: %Chess.Square.Sees{up: [], ...}}, {4, :h} => %Chess.Square{column: :h, row: 4, loc: {4, :h}, piece: nil, sees: %Chess.Square.Sees{...}}, {8, :b} => %Chess.Square{column: :b (truncated)
23:24:31.760 [error] GenServer #PID<0.2389.0> terminating
** (FunctionClauseError) no function clause matching in Chess.Pieces.PiecesLib.generate_paths/3
    (chess 0.1.0) lib/chess/pieces/pieces_lib.ex:17: Chess.Pieces.PiecesLib.generate_paths(%Chess.Square{column: :e, row: 8, loc: {8, :e}, piece: :K, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, 0}, 1)
    (elixir 1.15.7) lib/enum.ex:1693: Enum."-map/2-lists^map/1-1-"/2
    (chess 0.1.0) lib/chess/pieces/king.ex:16: Chess.Pieces.King.moves/2
    (elixir 1.15.7) lib/enum.ex:4317: Enum.flat_map_list/2
    (chess 0.1.0) lib/chess/game.ex:50: Chess.Game.validate_move/3
    (chess 0.1.0) lib/chess/game.ex:23: Chess.Game.move/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:81: ChessWeb.Chesslive.handle_event/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:508: anonymous fn/3 in Phoenix.LiveView.Channel.view_handle_event/3
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:260: Phoenix.LiveView.Channel.handle_info/2
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:251: :proc_lib.wake_up/3
Last message: %Phoenix.Socket.Message{topic: "lv:phx-GEhobmk3qu8CCQUB", event: "event", payload: %{"event" => "square-click", "type" => "click", "value" => %{"column" => "g", "row" => "7"}}, ref: "107", join_ref: "87"}
State: %{socket: #Phoenix.LiveView.Socket<id: "phx-GEhobmk3qu8CCQUB", endpoint: ChessWeb.Endpoint, view: ChessWeb.Chesslive, parent_pid: nil, root_pid: #PID<0.2389.0>, router: ChessWeb.Router, assigns: %{__changed__: %{}, flash: %{}, live_action: nil, clicked_square: {8, :e}, game: %Chess.Game{board: %Chess.Board{squares: %{{3, :c} => %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :g} => %Chess.Square{column: :g, row: 1, loc: {1, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :c} => %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :d} => %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :c} => %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :h} => %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :a} => %Chess.Square{column: :a, row: 6, loc: {6, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :e} => %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :f} => %Chess.Square{column: :f, row: 7, loc: {7, :f}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :d} => %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :a} => %Chess.Square{column: :a, row: 4, loc: {4, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :e} => %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :b} => %Chess.Square{column: :b, row: 6, loc: {6, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :h} => %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :b} => %Chess.Square{column: :b, row: 5, loc: {5, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :e} => %Chess.Square{column: :e, row: 5, loc: {5, :e}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :d} => %Chess.Square{column: :d, row: 6, loc: {6, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :f} => %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :d} => %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :e} => %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :e} => %Chess.Square{column: :e, row: 7, loc: {7, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], ...}}, {2, :g} => %Chess.Square{column: :g, row: 2, loc: {2, :g}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], ...}}, {4, :g} => %Chess.Square{column: :g, row: 4, loc: {4, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], ...}}, {7, :c} => %Chess.Square{column: :c, row: 7, loc: {7, :c}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], ...}}, {8, :h} => %Chess.Square{column: :h, row: 8, loc: {8, :h}, piece: :R, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], ...}}, {4, :b} => %Chess.Square{column: :b, row: 4, loc: {4, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], ...}}, {6, :f} => %Chess.Square{column: :f, row: 6, loc: {6, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], ...}}, {2, :c} => %Chess.Square{column: :c, row: 2, loc: {2, :c}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], ...}}, {5, :g} => %Chess.Square{column: :g, row: 5, loc: {5, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], ...}}, {4, :h} => %Chess.Square{column: :h, row: 4, loc: {4, :h}, piece: nil, sees: %Chess.Square.Sees{...}}, {8, :b} => %Chess.Square{column: :b, row: (truncated)
20:47:59.676 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
20:48:19.656 [error] ** (Bandit.HTTPError) closed
21:24:49.600 [error] `inotify-tools` is needed to run `file_system` for your system, check https://github.com/rvoicilas/inotify-tools/wiki for more information about how to install it. If it's already installed but not be found, appoint executable file with `config.exs` or `FILESYSTEM_FSINOTIFY_EXECUTABLE_FILE` env.
21:25:16.203 [error] GenServer #PID<0.853.0> terminating
** (WithClauseError) no with clause matching: false
    (chess 0.1.0) lib/chess/game.ex:23: Chess.Game.move/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:81: ChessWeb.Chesslive.handle_event/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:508: anonymous fn/3 in Phoenix.LiveView.Channel.view_handle_event/3
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:260: Phoenix.LiveView.Channel.handle_info/2
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:241: :proc_lib.init_p_do_apply/3
Last message: %Phoenix.Socket.Message{topic: "lv:phx-GElN0jvR8F27BwOk", event: "event", payload: %{"event" => "square-click", "type" => "click", "value" => %{"column" => "g", "row" => "3"}}, ref: "25", join_ref: "4"}
State: %{socket: #Phoenix.LiveView.Socket<id: "phx-GElN0jvR8F27BwOk", endpoint: ChessWeb.Endpoint, view: ChessWeb.Chesslive, parent_pid: nil, root_pid: #PID<0.853.0>, router: ChessWeb.Router, assigns: %{__changed__: %{}, flash: %{}, game: %Chess.Game{board: %Chess.Board{squares: %{{3, :c} => %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :f} => %Chess.Square{column: :f, row: 6, loc: {6, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :c} => %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :g} => %Chess.Square{column: :g, row: 8, loc: {8, :g}, piece: :N, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :a} => %Chess.Square{column: :a, row: 6, loc: {6, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :d} => %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :c} => %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :h} => %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :e} => %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :b} => %Chess.Square{column: :b, row: 5, loc: {5, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :a} => %Chess.Square{column: :a, row: 4, loc: {4, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :d} => %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :e} => %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :g} => %Chess.Square{column: :g, row: 7, loc: {7, :g}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :h} => %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :e} => %Chess.Square{column: :e, row: 5, loc: {5, :e}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :a} => %Chess.Square{column: :a, row: 7, loc: {7, :a}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :d} => %Chess.Square{column: :d, row: 6, loc: {6, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :a} => %Chess.Square{column: :a, row: 1, loc: {1, :a}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :f} => %Chess.Square{column: :f, row: 1, loc: {1, :f}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :b} => %Chess.Square{column: :b, row: 7, loc: {7, :b}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :d} => %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :f} => %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], ...}}, {6, :g} => %Chess.Square{column: :g, row: 6, loc: {6, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], ...}}, {2, :e} => %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], ...}}, {7, :e} => %Chess.Square{column: :e, row: 7, loc: {7, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], ...}}, {4, :b} => %Chess.Square{column: :b, row: 4, loc: {4, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], ...}}, {1, :g} => %Chess.Square{column: :g, row: 1, loc: {1, :g}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], ...}}, {7, :c} => %Chess.Square{column: :c, row: 7, loc: {7, :c}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], ...}}, {8, :h} => %Chess.Square{column: :h, row: 8, loc: {8, :h}, piece: :R, sees: %Chess.Square.Sees{up: [], down: [], ...}}, {2, :b} => %Chess.Square{column: :b, row: 2, loc: {2, :b}, piece: :p, sees: %Chess.Square.Sees{up: [], ...}}, {2, :g} => %Chess.Square{column: :g, row: 2, loc: {2, :g}, piece: :p, sees: %Chess.Square.Sees{...}}, {2, :c} => %Chess.Square{column: :c, row: 2, loc: {2, ...}, piece: :p, ...}, {8, :b} => %Chess.Square{column: :b, row: 8, loc: {...}, ...}, {3, :g} => %Chess.Square{column: :g, row: 3, ...}, {4, ...} => %Chess.Square{column: :h, ...}, {...} => %Chess.Square{... (truncated)
21:26:13.514 [error] GenServer #PID<0.899.0> terminating
** (KeyError) key :board not found in: {:error, :king_in_check_after_move}

If you are using the dot syntax, such as map.field, make sure the left-hand side of the dot is a map
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:26: anonymous fn/5 in ChessWeb.Chesslive.render/1
    (elixir 1.15.7) lib/enum.ex:2510: Enum."-reduce/3-lists^foldl/2-0-"/3
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:25: anonymous fn/3 in ChessWeb.Chesslive.render/1
    (elixir 1.15.7) lib/enum.ex:4356: Enum.map/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:23: anonymous fn/2 in ChessWeb.Chesslive.render/1
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:391: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:555: anonymous fn/4 in Phoenix.LiveView.Diff.traverse_dynamic/7
    (elixir 1.15.7) lib/enum.ex:2510: Enum."-reduce/3-lists^foldl/2-0-"/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:389: Phoenix.LiveView.Diff.traverse/7
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/diff.ex:136: Phoenix.LiveView.Diff.render/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:960: anonymous fn/4 in Phoenix.LiveView.Channel.render_diff/3
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:955: Phoenix.LiveView.Channel.render_diff/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:811: Phoenix.LiveView.Channel.handle_changed/4
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:241: :proc_lib.init_p_do_apply/3
Last message: %Phoenix.Socket.Message{topic: "lv:phx-GElN4hyFHK8VKQLh", event: "event", payload: %{"event" => "square-click", "type" => "click", "value" => %{"column" => "g", "row" => "3"}}, ref: "25", join_ref: "4"}
State: %{socket: #Phoenix.LiveView.Socket<id: "phx-GElN4hyFHK8VKQLh", endpoint: ChessWeb.Endpoint, view: ChessWeb.Chesslive, parent_pid: nil, root_pid: #PID<0.899.0>, router: ChessWeb.Router, assigns: %{__changed__: %{}, flash: %{}, game: %Chess.Game{board: %Chess.Board{squares: %{{3, :c} => %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :f} => %Chess.Square{column: :f, row: 6, loc: {6, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :c} => %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :g} => %Chess.Square{column: :g, row: 8, loc: {8, :g}, piece: :N, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :a} => %Chess.Square{column: :a, row: 6, loc: {6, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :d} => %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :c} => %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :h} => %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :e} => %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :b} => %Chess.Square{column: :b, row: 5, loc: {5, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :a} => %Chess.Square{column: :a, row: 4, loc: {4, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :d} => %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :e} => %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :g} => %Chess.Square{column: :g, row: 7, loc: {7, :g}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :h} => %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :e} => %Chess.Square{column: :e, row: 5, loc: {5, :e}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :a} => %Chess.Square{column: :a, row: 7, loc: {7, :a}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :d} => %Chess.Square{column: :d, row: 6, loc: {6, :d}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :a} => %Chess.Square{column: :a, row: 1, loc: {1, :a}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :f} => %Chess.Square{column: :f, row: 1, loc: {1, :f}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :b} => %Chess.Square{column: :b, row: 7, loc: {7, :b}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :d} => %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :f} => %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], ...}}, {6, :g} => %Chess.Square{column: :g, row: 6, loc: {6, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], ...}}, {2, :e} => %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], ...}}, {7, :e} => %Chess.Square{column: :e, row: 7, loc: {7, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], ...}},  (truncated)
21:28:36.661 [error] ** (Bandit.HTTPError) closed
21:28:44.171 [error] GenServer #PID<0.979.0> terminating
** (WithClauseError) no with clause matching: false
    (chess 0.1.0) lib/chess/game.ex:23: Chess.Game.move/2
    (chess 0.1.0) lib/chess_web/live/chesslive.ex:81: ChessWeb.Chesslive.handle_event/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:508: anonymous fn/3 in Phoenix.LiveView.Channel.view_handle_event/3
    (telemetry 1.3.0) /home/gikes/Projects/Elixir/chess_live/chess/deps/telemetry/src/telemetry.erl:324: :telemetry.span/3
    (phoenix_live_view 1.0.0-rc.7) lib/phoenix_live_view/channel.ex:260: Phoenix.LiveView.Channel.handle_info/2
    (stdlib 5.2.3.1) gen_server.erl:1095: :gen_server.try_handle_info/3
    (stdlib 5.2.3.1) gen_server.erl:1183: :gen_server.handle_msg/6
    (stdlib 5.2.3.1) proc_lib.erl:241: :proc_lib.init_p_do_apply/3
Last message: %Phoenix.Socket.Message{topic: "lv:phx-GElOBbAn4gL_fwHl", event: "event", payload: %{"event" => "square-click", "type" => "click", "value" => %{"column" => "g", "row" => "3"}}, ref: "21", join_ref: "4"}
State: %{socket: #Phoenix.LiveView.Socket<id: "phx-GElOBbAn4gL_fwHl", endpoint: ChessWeb.Endpoint, view: ChessWeb.Chesslive, parent_pid: nil, root_pid: #PID<0.979.0>, router: ChessWeb.Router, assigns: %{__changed__: %{}, flash: %{}, game: %Chess.Game{board: %Chess.Board{squares: %{{3, :c} => %Chess.Square{column: :c, row: 3, loc: {3, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :f} => %Chess.Square{column: :f, row: 6, loc: {6, :f}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :c} => %Chess.Square{column: :c, row: 4, loc: {4, :c}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {8, :g} => %Chess.Square{column: :g, row: 8, loc: {8, :g}, piece: :N, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :a} => %Chess.Square{column: :a, row: 6, loc: {6, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :d} => %Chess.Square{column: :d, row: 3, loc: {3, :d}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :c} => %Chess.Square{column: :c, row: 1, loc: {1, :c}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :h} => %Chess.Square{column: :h, row: 2, loc: {2, :h}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :e} => %Chess.Square{column: :e, row: 1, loc: {1, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :b} => %Chess.Square{column: :b, row: 5, loc: {5, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {4, :a} => %Chess.Square{column: :a, row: 4, loc: {4, :a}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :d} => %Chess.Square{column: :d, row: 1, loc: {1, :d}, piece: :q, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {3, :e} => %Chess.Square{column: :e, row: 3, loc: {3, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :g} => %Chess.Square{column: :g, row: 7, loc: {7, :g}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :h} => %Chess.Square{column: :h, row: 1, loc: {1, :h}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {5, :e} => %Chess.Square{column: :e, row: 5, loc: {5, :e}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :a} => %Chess.Square{column: :a, row: 7, loc: {7, :a}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {6, :d} => %Chess.Square{column: :d, row: 6, loc: {6, :d}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :a} => %Chess.Square{column: :a, row: 1, loc: {1, :a}, piece: :r, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {1, :f} => %Chess.Square{column: :f, row: 1, loc: {1, :f}, piece: :b, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {7, :b} => %Chess.Square{column: :b, row: 7, loc: {7, :b}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :d} => %Chess.Square{column: :d, row: 2, loc: {2, :d}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], all: MapSet.new([])}}, {2, :f} => %Chess.Square{column: :f, row: 2, loc: {2, :f}, piece: :p, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], knight: [], ...}}, {6, :g} => %Chess.Square{column: :g, row: 6, loc: {6, :g}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], down_right: [], ...}}, {2, :e} => %Chess.Square{column: :e, row: 2, loc: {2, :e}, piece: :k, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], down_left: [], ...}}, {7, :e} => %Chess.Square{column: :e, row: 7, loc: {7, :e}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], up_left: [], ...}}, {4, :b} => %Chess.Square{column: :b, row: 4, loc: {4, :b}, piece: nil, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], up_right: [], ...}}, {1, :g} => %Chess.Square{column: :g, row: 1, loc: {1, :g}, piece: :n, sees: %Chess.Square.Sees{up: [], down: [], left: [], right: [], ...}}, {7, :c} => %Chess.Square{column: :c, row: 7, loc: {7, :c}, piece: :P, sees: %Chess.Square.Sees{up: [], down: [], left: [], ...}}, {8, :h} => %Chess.Square{column: :h, row: 8, loc: {8, :h}, piece: :R, sees: %Chess.Square.Sees{up: [], down: [], ...}}, {2, :b} => %Chess.Square{column: :b, row: 2, loc: {2, :b}, piece: :p, sees: %Chess.Square.Sees{up: [], ...}}, {2, :g} => %Chess.Square{column: :g, row: 2, loc: {2, :g}, piece: :p, sees: %Chess.Square.Sees{...}}, {2, :c} => %Chess.Square{column: :c, row: 2, loc: {2, ...}, piece: :p, ...}, {8, :b} => %Chess.Square{column: :b, row: 8, loc: {...}, ...}, {3, :g} => %Chess.Square{column: :g, row: 3, ...}, {4, ...} => %Chess.Square{column: :h, ...}, {...} => %Chess.Square{... (truncated)
21:31:01.467 [error] ** (Bandit.HTTPError) closed
